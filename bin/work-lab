#!/usr/bin/env bash
# work-lab
# Copyright (c) 2026 Ryan Snodgrass. MIT License.
# A small convenience script for managing the work-lab devcontainer.
# This script is OPTIONAL. You can use the devcontainer CLI or VS Code directly.

set -Eeuo pipefail

VERSION="0.7.0"

# shellcheck disable=SC2155
readonly SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
# shellcheck disable=SC2155
readonly REPO_DIR="$(dirname -- "$SCRIPT_DIR")"

# error handler for debugging (only fires on unexpected errors)
_err_handler() {
  local code=$?
  # Skip if this is an intentional exit (INTENTIONAL_EXIT is set)
  [[ "${INTENTIONAL_EXIT:-0}" -eq 1 ]] && return 0
  printf "Error at line %d: exit %d\n" "$1" "$code" >&2
}
trap '_err_handler "$LINENO"' ERR

# Helper for intentional non-zero exits (avoids triggering error trap)
fail_exit() {
  INTENTIONAL_EXIT=1
  exit "${1:-1}"
}

# Source the styling library
# shellcheck source=../lib/style.sh
source "$REPO_DIR/lib/style.sh"

# ─────────────────────────────────────────────────────────────────────────────
# Portability helpers
# ─────────────────────────────────────────────────────────────────────────────
# Portable timeout command (macOS doesn't have timeout by default)
# Falls back to gtimeout (from coreutils) or returns failure (skip the operation)
_timeout() {
  local seconds="$1"
  shift
  if command -v timeout &>/dev/null; then
    timeout "$seconds" "$@"
  elif command -v gtimeout &>/dev/null; then
    gtimeout "$seconds" "$@"
  else
    # no timeout available - fail rather than hang indefinitely
    return 1
  fi
}

# Portable TCP port check with timeout
# Usage: _port_open host port [timeout_secs]
# Returns 0 if port is open, 1 otherwise
_port_open() {
  local host="$1" port="$2" timeout_secs="${3:-2}"
  # macOS nc uses -G for connect timeout, Linux/BSD uses -w
  if [[ "$(uname)" == "Darwin" ]]; then
    nc -z -G "$timeout_secs" "$host" "$port" 2>/dev/null
  else
    nc -z -w "$timeout_secs" "$host" "$port" 2>/dev/null
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────
# Defaults (can be overridden by ~/.config/work-lab/config or environment)
: "${WORK_LAB_IMAGE:=ghcr.io/modern-tooling/work-lab:latest}"
: "${WORK_LAB_MUX:=tmux}"  # terminal multiplexer: tmux or zellij

# Additional mounts (arrays, set in config file)
# Format: "source:target" - will be mounted read-only or read-write
WORK_LAB_MOUNTS_RO=()    # read-only mounts
WORK_LAB_MOUNTS_RW=(
  # Claude config (settings, API keys, session tokens)
  # Read-write so Claude CLI can persist authentication
  "$HOME/.claude:/home/worklab/.claude"
)

# Source user config if present (can override defaults above)
# SECURITY NOTE: Config is user-controlled. Path traversal in mounts is
# intentional - users explicitly configure what to mount. Anyone who can
# edit this file already has full host access.
config_file="$HOME/.config/work-lab/config"
if [[ -f "$config_file" ]]; then
  # Validate syntax before sourcing to provide helpful error messages
  if ! bash -n "$config_file" 2>/dev/null; then
    echo "Error: Syntax error in config file: $config_file" >&2
    echo "Fix the syntax error and try again." >&2
    exit 1
  fi
  # shellcheck source=/dev/null
  source "$config_file"
fi

# Export for devcontainer.json ${localEnv:...} substitution
export WORK_LAB_IMAGE

# ─────────────────────────────────────────────────────────────────────────────
# Container detection
# ─────────────────────────────────────────────────────────────────────────────
# Check if running inside work-lab container
# Detection: /opt/work-lab exists only inside the container image
is_inside_container() {
  [[ -d /opt/work-lab ]]
}

# Require running outside container (for host-only commands)
require_host() {
  if is_inside_container; then
    status_fail "This command must be run on the host, not inside work-lab"
    action "Exit container, then run from host terminal"
    fail_exit
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Project detection
# ─────────────────────────────────────────────────────────────────────────────
# Find the git root of the current directory (or empty if not in a git repo)
find_git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

# Get the project name from the git root directory
get_project_name() {
  local git_root="$1"
  basename "$git_root"
}

# Check if a project has a devcontainer configuration
# Handles all three patterns: .devcontainer/, .devcontainer.json, .devcontainer/devcontainer.json
has_devcontainer() {
  local project_path="$1"
  [[ -d "$project_path/.devcontainer" ]] || \
  [[ -f "$project_path/.devcontainer.json" ]] || \
  [[ -f "$project_path/.devcontainer/devcontainer.json" ]]
}

# Build mount flags for devcontainer up
# Note: devcontainer CLI requires --mount=VALUE format (with equals sign)
# Read-only not directly supported by devcontainer CLI, but we track intent
build_mount_flags() {
  local flags=()
  local mount_spec src_path tgt_path

  # Add read-only mounts (guard against empty array for Bash < 4.4)
  # Note: devcontainer CLI doesn't support readonly flag, so mounts are rw
  if (( ${#WORK_LAB_MOUNTS_RO[@]} > 0 )); then
    for mount_spec in "${WORK_LAB_MOUNTS_RO[@]}"; do
      # Validate format: must contain colon separator
      if [[ "$mount_spec" != *:* ]]; then
        status_fail "invalid mount spec (missing colon): $mount_spec" >&2
        continue
      fi
      src_path="${mount_spec%%:*}"
      tgt_path="${mount_spec#*:}"
      # Expand ~ and $HOME
      src_path="${src_path/#\~/$HOME}"
      src_path="${src_path//\$HOME/$HOME}"
      if [[ -e "$src_path" ]]; then
        flags+=("--mount=type=bind,source=$src_path,target=$tgt_path")
        status_ok "$src_path ${ICON_ARROW} $tgt_path (ro)" >&2
      else
        status_warn "skipping (not found): $src_path" >&2
      fi
    done
  fi

  # Add read-write mounts (guard against empty array for Bash < 4.4)
  if (( ${#WORK_LAB_MOUNTS_RW[@]} > 0 )); then
    for mount_spec in "${WORK_LAB_MOUNTS_RW[@]}"; do
      # Validate format: must contain colon separator
      if [[ "$mount_spec" != *:* ]]; then
        status_fail "invalid mount spec (missing colon): $mount_spec" >&2
        continue
      fi
      src_path="${mount_spec%%:*}"
      tgt_path="${mount_spec#*:}"
      # Expand ~ and $HOME
      src_path="${src_path/#\~/$HOME}"
      src_path="${src_path//\$HOME/$HOME}"
      if [[ -e "$src_path" ]]; then
        flags+=("--mount=type=bind,source=$src_path,target=$tgt_path")
        status_ok "$src_path ${ICON_ARROW} $tgt_path (rw)" >&2
      else
        status_warn "skipping (not found): $src_path" >&2
      fi
    done
  fi

  # Output flags (guard against empty array)
  if (( ${#flags[@]} > 0 )); then
    printf '%s\n' "${flags[@]}"
  fi
}

usage() {
  # Context-aware: dim entire line for commands that don't work here
  local HOST_ONLY=""  # styling for host-only commands
  local inside=""

  if is_inside_container; then
    HOST_ONLY="$C_DIM"  # dim the whole line when inside
    inside=" ${C_DIM}(inside container)${C_RESET}"
  fi

  echo ""
  printf "${C_BOLD}work-lab${C_RESET}%s\n" "$inside"
  print_dim "containerized environment for AI coding agents"
  echo ""
  print_accent "Usage:"
  echo "  work-lab <command>"
  echo ""
  print_accent "Commands:"
  echo ""
  # Lifecycle commands (host-only)
  printf "  ${C_PRIMARY}Lifecycle${C_RESET}\n"
  printf "    ${HOST_ONLY}${C_COMMAND}%-14s${C_RESET}${HOST_ONLY} %s${C_RESET}\n" "start" "Start work-lab for the current git project"
  printf "    ${HOST_ONLY}${C_COMMAND}%-14s${C_RESET}${HOST_ONLY} %s${C_RESET}\n" "stop" "Stop the container"
  printf "    ${HOST_ONLY}${C_COMMAND}%-14s${C_RESET}${HOST_ONLY} %s${C_RESET}\n" "rebuild" "Stop, remove, and start fresh"
  echo ""
  # Session commands
  printf "  ${C_PRIMARY}Session${C_RESET}\n"
  printf "    ${HOST_ONLY}${C_COMMAND}%-14s${C_RESET}${HOST_ONLY} Attach to tmux session ${C_DIM}(recommended)${C_RESET}\n" "mux [project]"
  printf "    ${C_COMMAND}%-14s${C_RESET} %s\n" "shell" "Run a one-off shell command"
  printf "    ${HOST_ONLY}${C_COMMAND}%-14s${C_RESET}${HOST_ONLY} %s${C_RESET}\n" "ps" "List running work-lab containers"
  echo ""
  # Paired Devcontainer commands
  printf "  ${C_PRIMARY}Paired Devcontainer${C_RESET}\n"
  printf "    ${C_COMMAND}%-14s${C_RESET} %s\n" "dc <cmd>" "Run command in project's devcontainer"
  printf "    ${C_COMMAND}%-14s${C_RESET} %s\n" "ports" "Show forwarded ports"
  echo ""
  # Maintenance commands
  printf "  ${C_PRIMARY}Maintenance${C_RESET}\n"
  printf "    ${C_COMMAND}%-14s${C_RESET} Check environment ${C_DIM}(--fix to auto-repair)${C_RESET}\n" "doctor"
  printf "    ${HOST_ONLY}${C_COMMAND}%-14s${C_RESET}${HOST_ONLY} %s${C_RESET}\n" "prune" "Clean up stopped containers"
  echo ""
  # Info commands
  printf "  ${C_PRIMARY}Info${C_RESET}\n"
  printf "    ${C_COMMAND}%-14s${C_RESET} %s\n" "version" "Show version information"
  printf "    ${C_COMMAND}%-14s${C_RESET} %s\n" "release-notes" "Show release notes"
  printf "    ${C_COMMAND}%-14s${C_RESET} %s\n" "help" "Show this message"
  echo ""
  print_dim "https://github.com/modern-tooling/work-lab"
  echo ""
}

cmd_version() {
  printf "${C_BOLD}work-lab${C_RESET} ${C_COMMAND}%s${C_RESET}\n" "$VERSION"
}

cmd_release_notes() {
  local url="https://api.github.com/repos/modern-tooling/work-lab/releases"
  local releases

  header "work-lab release notes"
  printf "  ${C_LABEL}current${C_RESET}  ${C_COMMAND}v%s${C_RESET}\n" "$VERSION"

  if ! command -v curl &>/dev/null; then
    print_dim "curl not available"
    action "Releases: ${C_COMMAND}https://github.com/modern-tooling/work-lab/releases${C_ACTION}"
    return
  fi

  releases=$(curl -sL "$url" 2>/dev/null)
  if [[ -z "$releases" ]] || ! echo "$releases" | jq -e '.' &>/dev/null; then
    print_dim "Could not fetch release notes"
    action "Releases: ${C_COMMAND}https://github.com/modern-tooling/work-lab/releases${C_ACTION}"
    return
  fi

  # Helper to strip markdown formatting
  _strip_md() {
    local s="$1"
    s="${s//\`/}"      # backticks
    s="${s//\*\*/}"    # bold markers
    echo "$s"
  }

  # Format and display each release
  local in_code_block=0
  local parsed
  if ! parsed=$(echo "$releases" | jq -r '.[] | "\(.tag_name)\n\(.body)\n---END---"' 2>/dev/null); then
    print_dim "No releases found"
    action "Releases: ${C_COMMAND}https://github.com/modern-tooling/work-lab/releases${C_ACTION}"
    return 0
  fi
  echo "$parsed" | while IFS= read -r line; do
    # Version header
    if [[ "$line" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      local tag="$line"
      echo ""
      printf "${C_DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C_RESET}\n"
      if [[ "$tag" == "v$VERSION" ]]; then
        printf "${C_BOLD}${C_PRIMARY}%s${C_RESET}  ${C_PASS}[current]${C_RESET}\n" "$tag"
      else
        printf "${C_BOLD}${C_PRIMARY}%s${C_RESET}\n" "$tag"
      fi
      printf "${C_DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C_RESET}\n"
      in_code_block=0
    # Section end marker
    elif [[ "$line" == "---END---" ]]; then
      continue
    # Code block toggle
    elif [[ "$line" == '```'* ]]; then
      in_code_block=$((1 - in_code_block))
      continue
    # Inside code block - print dimmed with indent
    elif (( in_code_block )); then
      printf "      ${C_DIM}%s${C_RESET}\n" "$line"
    # H2 headers (## Something) -> Section headers
    elif [[ "$line" =~ ^##[[:space:]](.+)$ ]]; then
      local section="${BASH_REMATCH[1]}"
      section=$(_strip_md "$section")
      # Skip "What's New" - redundant
      [[ "$section" == "What's New" ]] && continue
      printf "\n${C_ACCENT}%s${C_RESET}\n" "${section^^}"
    # H3 headers (### Something) -> Subsection
    elif [[ "$line" =~ ^###[[:space:]](.+)$ ]]; then
      local subsection="${BASH_REMATCH[1]}"
      subsection=$(_strip_md "$subsection")
      printf "\n  ${C_BOLD}%s${C_RESET}\n" "$subsection"
    # Bullet points with bold labels (- **Label**: description)
    elif [[ "$line" =~ ^-[[:space:]]\*\*([^*]+)\*\*:[[:space:]](.+)$ ]]; then
      local label="${BASH_REMATCH[1]}"
      local desc
      desc=$(_strip_md "${BASH_REMATCH[2]}")
      printf "    ${C_LABEL}%-18s${C_RESET} %s\n" "$label" "$desc"
    # Bullet points with bold labels (- **Label** description without colon)
    elif [[ "$line" =~ ^-[[:space:]]\*\*([^*]+)\*\*[[:space:]]?(.*)$ ]]; then
      local label="${BASH_REMATCH[1]}"
      local desc
      desc=$(_strip_md "${BASH_REMATCH[2]}")
      if [[ -n "$desc" ]]; then
        printf "    ${C_LABEL}%-18s${C_RESET} %s\n" "$label" "$desc"
      else
        printf "    ${C_LABEL}%s${C_RESET}\n" "$label"
      fi
    # Plain bullet points
    elif [[ "$line" =~ ^-[[:space:]](.+)$ ]]; then
      local item
      item=$(_strip_md "${BASH_REMATCH[1]}")
      printf "    • %s\n" "$item"
    # Numbered list items
    elif [[ "$line" =~ ^[0-9]+\.[[:space:]](.+)$ ]]; then
      local item
      item=$(_strip_md "${BASH_REMATCH[1]}")
      printf "    %s\n" "$item"
    # Commit lines (special case: backtick-wrapped hash)
    elif [[ "$line" =~ ^\`([a-f0-9]+)\`[[:space:]](.+)$ ]]; then
      printf "    ${C_WARN}%s${C_RESET}  %s\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
    # Horizontal rules
    elif [[ "$line" == "---" ]]; then
      continue
    # Links (Full Changelog etc)
    elif [[ "$line" =~ ^https:// ]]; then
      printf "    ${C_DIM}%s${C_RESET}\n" "$line"
    # Empty lines
    elif [[ -z "$line" ]]; then
      echo ""
    # Everything else - strip markdown and print
    else
      local clean
      clean=$(_strip_md "$line")
      [[ -n "$clean" ]] && printf "  %s\n" "$clean"
    fi
  done
}

# Find the work-lab container for current project
# Looks for containers with /workspaces/project mounted to current git root
# Returns empty string if not found (always returns 0 to avoid errexit issues)
find_container() {
  local project_root
  project_root=$(find_git_root 2>/dev/null) || { echo ""; return 0; }

  local cid

  # First, try to find by work-lab.container label (new containers)
  while read -r cid; do
    [[ -z "$cid" ]] && continue
    local mount_source
    mount_source=$(docker inspect "$cid" --format '{{range .Mounts}}{{if eq .Destination "/workspaces/project"}}{{.Source}}{{end}}{{end}}' 2>/dev/null)
    if [[ "$mount_source" == "$project_root" ]]; then
      echo "$cid"
      return 0
    fi
  done < <(docker ps -q --filter "label=work-lab.container=true" 2>/dev/null)

  # Fallback: check legacy containers (local_folder pointing to work-lab repo)
  while read -r cid; do
    [[ -z "$cid" ]] && continue
    local mount_source
    mount_source=$(docker inspect "$cid" --format '{{range .Mounts}}{{if eq .Destination "/workspaces/project"}}{{.Source}}{{end}}{{end}}' 2>/dev/null)
    if [[ "$mount_source" == "$project_root" ]]; then
      echo "$cid"
      return 0
    fi
  done < <(docker ps -q --filter "label=devcontainer.local_folder" 2>/dev/null)

  echo ""
  return 0
}

# Check if SSH tunnel credentials exist for a project
# Uses shared filesystem approach - no Docker socket needed
# Returns 0 if credentials found, 1 otherwise
check_project_ssh_tunnel() {
  local project_path="$1"
  [[ -f "$project_path/.work-lab/ssh-key" ]] && \
  [[ -f "$project_path/.work-lab/ip" ]]
}

# Check if a devcontainer has sshd available (quick port probe)
# Returns 0 if sshd detected, 1 otherwise
check_devcontainer_sshd() {
  local container_id="$1"
  # Check from inside container (Docker Desktop on Mac can't reach container IPs)
  docker exec "$container_id" sh -c 'nc -z localhost 22 2>/dev/null || ss -tln 2>/dev/null | grep -q ":22 "' 2>/dev/null
}

# Ensure SSH tunnel is set up for a project
# Called lazily by mux/shell/doctor - runs on HOST with Docker access
#
# DESIGN NOTES:
# - Only creates .work-lab/ when devcontainer exists AND has sshd running
#   (don't clutter projects that don't use devcontainers)
# - Creates shared Docker network for routing between containers
#   (by default, each devcontainer is on its own network)
# - Injects public key via docker exec (host has Docker access, work-lab doesn't)
# - work-lab reads credentials from .work-lab/ to connect (no Docker needed)
#
# SECURITY NOTE: SSH keys are generated by work-lab via ssh-keygen. The pubkey
# is injected into the devcontainer's authorized_keys. This is safe because:
# 1. The host already has Docker access (can docker exec into any container)
# 2. Files are created in user's project directory (user-controlled)
# 3. If an attacker can modify these files, they already have host access
#
ensure_ssh_tunnel() {
  local project_path="$1"
  local worklab_dir="$project_path/.work-lab"
  local key_file="$worklab_dir/ssh-key"
  local pubkey_file="$worklab_dir/ssh-key.pub"
  local ip_file="$worklab_dir/ip"
  local user_file="$worklab_dir/user"

  # Find project's devcontainer first - don't create .work-lab/ if no devcontainer
  local project_name dc_id
  project_name=$(basename "$project_path")

  dc_id=$(docker ps --filter "label=devcontainer.local_folder=$project_path" \
    --format "{{.ID}}" 2>/dev/null | head -n 1)

  if [[ -z "$dc_id" ]]; then
    # No devcontainer running - don't create .work-lab/ (keep project clean)
    return 0
  fi

  # Check if devcontainer has sshd running before creating anything
  # Check if sshd is running in the devcontainer
  if ! check_devcontainer_sshd "$dc_id"; then
    # sshd not running - don't create .work-lab/ (user hasn't enabled sshd feature)
    return 0
  fi

  # Get container IP for SSH connection
  local dc_ip
  dc_ip=$(docker inspect --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$dc_id" 2>/dev/null | head -1)

  if [[ -z "$dc_ip" ]]; then
    return 0
  fi

  # At this point we have a running devcontainer with sshd - proceed with setup

  # Create .work-lab directory if needed
  if [[ ! -d "$worklab_dir" ]]; then
    mkdir -p "$worklab_dir"
    chmod 700 "$worklab_dir"
  fi

  # Generate SSH keypair if needed
  if [[ ! -f "$key_file" ]]; then
    ssh-keygen -t ed25519 -f "$key_file" -N "" -q -C "work-lab-tunnel"
    chmod 600 "$key_file"
    chmod 644 "$pubkey_file"
  fi

  # NOTE: We intentionally do NOT auto-modify .gitignore
  # Users should add .work-lab/ to their .gitignore if desired
  # This avoids cluttering projects and surprising users with file changes

  # Find work-lab container for this project (to set up network routing)
  local wl_id
  wl_id=$(find_container)

  # Create shared network for tunnel routing (containers on different networks can't reach each other)
  # This is idempotent - network is created once and reused
  docker network create work-lab-tunnel 2>/dev/null || true

  # Connect both containers to shared network (idempotent - won't error if already connected)
  if [[ -n "$wl_id" ]]; then
    docker network connect work-lab-tunnel "$wl_id" 2>/dev/null || true
  fi
  docker network connect work-lab-tunnel "$dc_id" 2>/dev/null || true

  # Get devcontainer's IP on the shared network (may differ from original IP)
  local tunnel_ip
  tunnel_ip=$(docker inspect --format '{{range $k, $v := .NetworkSettings.Networks}}{{if eq $k "work-lab-tunnel"}}{{$v.IPAddress}}{{end}}{{end}}' "$dc_id" 2>/dev/null)

  # Fall back to original IP if shared network IP not available
  if [[ -z "$tunnel_ip" ]]; then
    tunnel_ip="$dc_ip"
  fi

  # Find the SSH user in devcontainer
  local dc_user
  dc_user=$(docker inspect --format '{{.Config.User}}' "$dc_id" 2>/dev/null)
  if [[ -z "$dc_user" ]] || [[ "$dc_user" == "root" ]]; then
    for try_user in vscode node; do
      if docker exec "$dc_id" id "$try_user" &>/dev/null; then
        dc_user="$try_user"
        break
      fi
    done
  fi
  dc_user="${dc_user:-root}"

  # Write connection info (using tunnel network IP)
  echo "$tunnel_ip" > "$ip_file"
  echo "$dc_user" > "$user_file"

  # Inject public key into devcontainer's authorized_keys (if not already there)
  local pubkey
  pubkey=$(cat "$pubkey_file")

  docker exec "$dc_id" bash -c "
    mkdir -p ~/.ssh
    chmod 700 ~/.ssh
    touch ~/.ssh/authorized_keys
    chmod 600 ~/.ssh/authorized_keys
    if ! grep -qF 'work-lab-tunnel' ~/.ssh/authorized_keys 2>/dev/null; then
      echo '$pubkey' >> ~/.ssh/authorized_keys
    fi
  " 2>/dev/null || true
}

# List devcontainers grouped by project, showing work-lab + devcontainer pairs
cmd_ps() {
  require_host

  header "Running containers"

  # Get all running devcontainers
  # Include work-lab.container label to distinguish work-lab containers
  local containers
  containers=$(docker ps --filter "label=devcontainer.local_folder" \
    --format "{{.ID}}|{{.Names}}|{{.Label \"devcontainer.local_folder\"}}|{{.Status}}|{{.Label \"work-lab.container\"}}" 2>/dev/null)

  if [[ -z "$containers" ]]; then
    status_info "none running"
    action "Run ${C_COMMAND}work-lab start${C_ACTION}"
    return
  fi

  # Build associative arrays for work-labs and project devcontainers
  # worklabs_for_project stores space-separated container IDs to support multiple sessions
  declare -A worklabs_for_project  # project_path -> "cid1 cid2 ..."
  declare -A devcontainer_for_project  # project_path -> container_id
  declare -A container_name  # container_id -> name
  declare -a projects  # ordered list of projects

  while IFS='|' read -r cid cname local_folder _status is_worklab; do
    container_name["$cid"]="$cname"

    # Check if this is a work-lab container
    # New containers have work-lab.container=true label
    # Legacy containers have local_folder pointing to work-lab repo
    if [[ "$is_worklab" == "true" ]] || [[ "$local_folder" == *"/work-lab" ]] || [[ "$local_folder" == "$REPO_DIR" ]]; then
      # Find the mounted project path
      local project_mount
      project_mount=$(docker inspect "$cid" --format '{{range .Mounts}}{{if eq .Destination "/workspaces/project"}}{{.Source}}{{end}}{{end}}' 2>/dev/null)
      if [[ -n "$project_mount" ]]; then
        # Append to existing work-labs for this project (space-separated)
        local existing="${worklabs_for_project[$project_mount]:-}"
        if [[ -z "$existing" ]]; then
          worklabs_for_project["$project_mount"]="$cid"
          # Add to projects list if not already there
          if [[ -z "${devcontainer_for_project[$project_mount]:-}" ]]; then
            projects+=("$project_mount")
          fi
        else
          worklabs_for_project["$project_mount"]="$existing $cid"
        fi
      fi
    else
      # It's a project devcontainer
      devcontainer_for_project["$local_folder"]="$cid"
      if [[ -z "${worklabs_for_project[$local_folder]:-}" ]]; then
        projects+=("$local_folder")
      fi
    fi
  done <<< "$containers"

  # If we're in a project with a .devcontainer, include it even if nothing running
  local current_project
  current_project=$(find_git_root 2>/dev/null)
  if [[ -n "$current_project" ]]; then
    # Add current project if it has a devcontainer and isn't already in the list
    if has_devcontainer "$current_project" && \
       [[ -z "${worklabs_for_project[$current_project]:-}" ]] && \
       [[ -z "${devcontainer_for_project[$current_project]:-}" ]]; then
      projects+=("$current_project")
    fi
  fi

  # Display grouped by project
  local project_count=${#projects[@]}
  if (( project_count == 0 )); then
    status_info "none running"
    action "Run ${C_COMMAND}work-lab start${C_ACTION}"
    return
  fi

  for project in "${projects[@]}"; do
    local project_name
    project_name=$(basename "$project")

    # Show gold star for current project
    if [[ "$project" == "$current_project" ]]; then
      printf "\n${C_ACCENT}%s/${C_RESET} ${C_CURRENT}★${C_RESET}\n" "$project_name"
    else
      printf "\n${C_ACCENT}%s/${C_RESET}\n" "$project_name"
    fi

    local wl_ids="${worklabs_for_project[$project]:-}"
    local dc_id="${devcontainer_for_project[$project]:-}"

    # Convert space-separated IDs to array
    local -a wl_array=()
    if [[ -n "$wl_ids" ]]; then
      read -ra wl_array <<< "$wl_ids"
    fi
    local wl_count=${#wl_array[@]}

    if (( wl_count > 0 )) && [[ -n "$dc_id" ]]; then
      # Work-lab(s) + devcontainer running
      if (( wl_count == 1 )); then
        # Single work-lab session
        local wl_id="${wl_array[0]}"
        printf "  ├─ ${C_COMMAND}work-lab${C_RESET}      ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "${wl_id:0:12}" "${container_name[$wl_id]}"
      else
        # Multiple work-lab sessions sharing the same devcontainer
        local session_annotation
        session_annotation=$(printf "${C_ACCENT}(%d sessions)${C_RESET}" "$wl_count")
        printf "  ├─ ${C_COMMAND}work-lab${C_RESET}      %b\n" "$session_annotation"
        local i=0
        for wl_id in "${wl_array[@]}"; do
          ((i++))
          local connector="│"
          if (( i == wl_count )); then
            connector="│"  # last work-lab, devcontainer follows
          fi
          printf "  %s   └─ ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "$connector" "${wl_id:0:12}" "${container_name[$wl_id]}"
        done
      fi
      # show devcontainer with SSH tunnel status
      local ssh_indicator=""
      if check_project_ssh_tunnel "$project"; then
        ssh_indicator="${C_SSH}⚡${C_RESET}"  # tunnel ready
      elif ! check_devcontainer_sshd "$dc_id"; then
        ssh_indicator="${C_WARN}⚠${C_RESET}"  # cannot tunnel (no sshd)
      fi
      printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET} %b\n" "${dc_id:0:12}" "${container_name[$dc_id]}" "$ssh_indicator"
    elif (( wl_count > 0 )); then
      # Only work-lab(s), no devcontainer running
      local project_has_dc=0
      if has_devcontainer "$project"; then
        project_has_dc=1
      fi
      if (( wl_count == 1 )); then
        local wl_id="${wl_array[0]}"
        if (( project_has_dc )); then
          # Show work-lab and stopped devcontainer as separate tree entries
          printf "  ├─ ${C_COMMAND}work-lab${C_RESET}      ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "${wl_id:0:12}" "${container_name[$wl_id]}"
          printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}────────────${C_RESET}  ${C_WARN}○${C_RESET}  ${C_WARN}stopped${C_RESET}\n"
        else
          # Standalone mode - no devcontainer available
          printf "  └─ ${C_COMMAND}work-lab${C_RESET}      ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET} ${C_DIM}(standalone)${C_RESET}\n" "${wl_id:0:12}" "${container_name[$wl_id]}"
        fi
      else
        # Multiple work-labs
        local i=0
        for wl_id in "${wl_array[@]}"; do
          ((i++)) || true
          local connector="├"
          if (( i == wl_count )) && (( ! project_has_dc )); then
            connector="└"
          fi
          printf "  %s─ ${C_COMMAND}work-lab${C_RESET}      ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "$connector" "${wl_id:0:12}" "${container_name[$wl_id]}"
        done
        if (( project_has_dc )); then
          printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}────────────${C_RESET}  ${C_WARN}○${C_RESET}  ${C_WARN}stopped${C_RESET}\n"
        fi
      fi
    elif [[ -n "$dc_id" ]]; then
      # Only devcontainer (no work-lab) - show work-lab as stopped, devcontainer as running
      printf "  ├─ ${C_DIM}work-lab${C_RESET}      ${C_DIM}────────────${C_RESET}  ${C_WARN}○${C_RESET}  ${C_WARN}stopped${C_RESET}\n"
      # show devcontainer with SSH tunnel status
      local ssh_indicator=""
      if check_project_ssh_tunnel "$project"; then
        ssh_indicator="${C_SSH}⚡${C_RESET}"  # tunnel ready
      elif ! check_devcontainer_sshd "$dc_id"; then
        ssh_indicator="${C_WARN}⚠${C_RESET}"  # cannot tunnel (no sshd)
      fi
      printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET} %b\n" "${dc_id:0:12}" "${container_name[$dc_id]}" "$ssh_indicator"
    else
      # Both stopped (current project with .devcontainer but nothing running)
      printf "  ├─ ${C_DIM}work-lab${C_RESET}      ${C_DIM}────────────${C_RESET}  ${C_WARN}○${C_RESET}  ${C_WARN}stopped${C_RESET}\n"
      printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}────────────${C_RESET}  ${C_WARN}○${C_RESET}  ${C_WARN}stopped${C_RESET}\n"
    fi
  done

  echo ""
  printf "${C_DIM}Legend: ${C_PASS}●${C_DIM} running  ${C_WARN}○${C_DIM} stopped  ${C_SSH}⚡${C_DIM} tunnel ready  ${C_WARN}⚠${C_DIM} no sshd${C_RESET}\n"
}

cmd_up() {
  require_host

  # Ensure config directory exists (required for devcontainer mount)
  mkdir -p "$HOME/.config/work-lab"

  if ! command -v devcontainer &> /dev/null; then
    status_fail "devcontainer CLI not found"
    action "Install: ${C_COMMAND}npm install -g @devcontainers/cli${C_ACTION}"
    fail_exit
  fi

  # Detect project from current directory
  local project_root project_name
  project_root=$(find_git_root)
  if [[ -z "$project_root" ]]; then
    status_fail "Not in a git repository"
    action "From git project root: ${C_COMMAND}work-lab start${C_ACTION}"
    fail_exit
  fi
  project_name=$(get_project_name "$project_root")

  banner "work-lab start"
  printf "  ${C_LABEL}project${C_RESET}  ${C_COMMAND}%s${C_RESET}\n" "$project_name"
  printf "  ${C_LABEL}path${C_RESET}     %s\n" "$project_root"

  # Build mount flags
  local mount_flags=()

  # Add project mount (the current git repo)
  mount_flags+=("--mount=type=bind,source=$project_root,target=/workspaces/project")
  printf "  ${C_LABEL}mount${C_RESET}    %s -> /workspaces/project\n" "$project_root"

  # Add additional mounts from config
  if (( ${#WORK_LAB_MOUNTS_RO[@]} > 0 )) || (( ${#WORK_LAB_MOUNTS_RW[@]} > 0 )); then
    echo ""
    subheader "Additional mounts:"
    readarray -t -O "${#mount_flags[@]}" mount_flags < <(build_mount_flags)
  fi

  # Check if Docker image is available (local or can be pulled)
  if ! docker image inspect "$WORK_LAB_IMAGE" &>/dev/null; then
    echo ""
    activity "Pulling work-lab image (first run)..."
    if ! docker pull "$WORK_LAB_IMAGE" 2>&1; then
      status_fail "Failed to pull Docker image: $WORK_LAB_IMAGE"
      action "Check network connection and retry"
      action "Manual pull: ${C_COMMAND}docker pull $WORK_LAB_IMAGE${C_ACTION}"
      fail_exit
    fi
  fi

  echo ""
  activity "Starting work-lab container..."

  # Run devcontainer up with error handling
  # Use --override-config to use work-lab's devcontainer.json
  # Use --workspace-folder for the actual project
  # Set both labels explicitly:
  #   - devcontainer.local_folder: for standard devcontainer tooling
  #   - work-lab.container: to identify this as a work-lab container
  local dc_output dc_exit=0
  dc_output=$(devcontainer up \
    --override-config "$REPO_DIR/.devcontainer/devcontainer.json" \
    --workspace-folder "$project_root" \
    --id-label "devcontainer.local_folder=$project_root" \
    --id-label "work-lab.container=true" \
    "${mount_flags[@]}" 2>&1) || dc_exit=$?

  if (( dc_exit != 0 )); then
    echo "$dc_output"
    echo ""
    status_fail "work-lab container up failed"
    # detect common errors and give hints
    if [[ "$dc_output" == *"ECONNREFUSED"* ]] || [[ "$dc_output" == *"ETIMEDOUT"* ]]; then
      action "Network error - check connection and retry"
    elif [[ "$dc_output" == *"not found"* ]] || [[ "$dc_output" == *"No such"* ]]; then
      action "Docker not running - start Docker Desktop or ${C_COMMAND}dockerd${C_ACTION}"
    fi
    fail_exit
  fi

  echo ""
  print_pass "Ready!"
  tip "${C_COMMAND}wl mux${C_TIP}   ${C_DIM}recommended - persistent session${C_TIP}"
  tip "${C_COMMAND}wl shell${C_TIP} ${C_DIM}one-off commands${C_TIP}"

  # Show sidecar mode tips
  if has_devcontainer "$project_root"; then
    echo ""
    subheader "Sidecar mode detected"
    detail "Project has its own devcontainer for building/testing"
    printf "  ${C_DIM}To run in paired devcontainer:${C_RESET} ${C_COMMAND}wl dc <cmd>${C_RESET}\n"
  fi
}

cmd_shell() {
  require_host

  local container_id
  container_id=$(find_container)
  if [[ -z "$container_id" ]]; then
    local project_name
    project_name=$(basename "$(find_git_root 2>/dev/null)" 2>/dev/null || echo "this project")
    status_fail "No work-lab running for $project_name"
    action "Start: ${C_COMMAND}work-lab start${C_ACTION}"
    fail_exit
  fi

  # Ensure SSH tunnel is set up (lazy initialization from host)
  local project_root
  project_root=$(find_git_root 2>/dev/null)
  if [[ -n "$project_root" ]]; then
    ensure_ssh_tunnel "$project_root"
  fi

  # Build docker exec flags based on TTY availability
  local -a exec_flags=("-u" "worklab" "-w" "/workspaces/project")
  if [[ -t 0 ]]; then
    exec_flags+=("-it")
  else
    exec_flags+=("-i")
  fi

  if [[ $# -gt 0 ]]; then
    # Run the provided command
    docker exec "${exec_flags[@]}" "$container_id" bash -c "$*"
  else
    # Interactive shell
    docker exec "${exec_flags[@]}" "$container_id" bash
  fi
}

cmd_mux() {
  require_host

  local target="${1:-}"
  local container_id

  if [[ -n "$target" ]]; then
    # Attach to specific project by name
    container_id=$(find_container_by_name "$target")
    if [[ -z "$container_id" ]]; then
      return 1  # find_container_by_name already printed error
    fi
  else
    # Attach to current project
    container_id=$(find_container)
    if [[ -z "$container_id" ]]; then
      local project_name
      project_name=$(basename "$(find_git_root 2>/dev/null)" 2>/dev/null || echo "this project")
      status_fail "No work-lab running for $project_name"
      action "Start: ${C_COMMAND}work-lab start${C_ACTION}"
      fail_exit
    fi

    # Ensure SSH tunnel is set up (lazy initialization from host)
    local project_root
    project_root=$(find_git_root 2>/dev/null)
    if [[ -n "$project_root" ]]; then
      ensure_ssh_tunnel "$project_root"
    fi
  fi

  # Check if configured mux is available in container
  if ! docker exec "$container_id" which "$WORK_LAB_MUX" &>/dev/null; then
    status_fail "$WORK_LAB_MUX not found in container"
    if [[ "$WORK_LAB_MUX" == "zellij" ]]; then
      action "Install zellij in ${C_COMMAND}~/.config/work-lab/post-create.sh${C_ACTION}"
    fi
    fail_exit
  fi

  # Get project name for window naming
  local project_name
  project_name=$(docker exec "$container_id" bash -c 'basename /workspaces/project 2>/dev/null' || echo "project")

  # Attach to existing session or create a new one named 'lab'
  # If a saved session exists, restore it; otherwise create fresh
  case "$WORK_LAB_MUX" in
    tmux)
      docker exec -it -u worklab -w /workspaces/project "$container_id" \
        bash -c "
          if tmux has-session -t lab 2>/dev/null; then
            tmux attach -t lab
          elif [[ -f /workspaces/project/.work-lab/tmux-session ]]; then
            wl-session-restore lab && tmux attach -t lab
          else
            tmux new-session -d -s lab -n '$project_name'
            tmux attach -t lab
          fi
        "
      ;;
    zellij)
      docker exec -it -u worklab -w /workspaces/project "$container_id" \
        zellij attach --create lab
      ;;
    *)
      status_fail "Unknown multiplexer: $WORK_LAB_MUX"
      action "Set ${C_COMMAND}WORK_LAB_MUX=tmux${C_ACTION} or ${C_COMMAND}zellij${C_ACTION}"
      fail_exit
      ;;
  esac
}

# Find work-lab container by project name (for wl mux <project>)
find_container_by_name() {
  local target="$1"

  # Get all running work-lab containers
  local containers
  containers=$(docker ps --filter "label=work-lab.container=true" \
    --format "{{.ID}}|{{.Label \"devcontainer.local_folder\"}}" 2>/dev/null)

  # Also check legacy containers
  local legacy
  legacy=$(docker ps --filter "label=devcontainer.local_folder" \
    --format "{{.ID}}|{{.Label \"devcontainer.local_folder\"}}" 2>/dev/null)

  local all_containers
  all_containers=$(echo -e "${containers}\n${legacy}" | sort -u | grep -v '^$')

  if [[ -z "$all_containers" ]]; then
    status_info "No work-lab containers running"
    action "Start one: ${C_COMMAND}cd <project> && wl start${C_ACTION}"
    return 1
  fi

  # Build list of work-lab containers
  declare -A worklab_containers
  local cid local_folder project_name

  while IFS='|' read -r cid local_folder; do
    [[ -z "$cid" ]] && continue
    local mount_source
    mount_source=$(docker inspect "$cid" --format '{{range .Mounts}}{{if eq .Destination "/workspaces/project"}}{{.Source}}{{end}}{{end}}' 2>/dev/null)
    if [[ -n "$mount_source" ]]; then
      project_name=$(basename "$mount_source")
      worklab_containers["$project_name"]="$cid"
    fi
  done <<< "$all_containers"

  if [[ ${#worklab_containers[@]} -eq 0 ]]; then
    status_info "No work-lab containers running"
    action "Start one: ${C_COMMAND}cd <project> && wl start${C_ACTION}"
    return 1
  fi

  # Find matching container
  local match_cid="" match_name=""

  for proj in "${!worklab_containers[@]}"; do
    if [[ "$proj" == "$target" ]]; then
      match_cid="${worklab_containers[$proj]}"
      match_name="$proj"
      break
    elif [[ "$proj" == *"$target"* ]]; then
      if [[ -n "$match_cid" ]]; then
        status_fail "Ambiguous: '$target' matches multiple projects"
        action "Be more specific or use exact name"
        return 1
      fi
      match_cid="${worklab_containers[$proj]}"
      match_name="$proj"
    fi
  done

  if [[ -z "$match_cid" ]]; then
    status_fail "No work-lab found for '$target'"
    echo ""
    header "Available work-labs"
    for proj in "${!worklab_containers[@]}"; do
      printf "  ${C_COMMAND}%s${C_RESET}\n" "$proj"
    done
    return 1
  fi

  echo "$match_cid"
}

cmd_stop() {
  require_host

  local container_id
  container_id=$(find_container)
  if [[ -z "$container_id" ]]; then
    status_info "Container not running"
    exit 0
  fi
  activity "Stopping container..."
  docker stop "$container_id" > /dev/null
  status_ok "Stopped"
}

cmd_rebuild() {
  require_host

  local container_id
  container_id=$(find_container)

  if [[ -n "$container_id" ]]; then
    activity "Stopping and removing old container..."
    docker rm -f "$container_id" > /dev/null 2>&1
    status_ok "Removed old container"
  fi

  # Start fresh with (potentially updated) image
  activity "Starting fresh container..."
  cmd_up
}

# Clean up stopped work-lab containers and optionally images
cmd_prune() {
  require_host

  local prune_all=false
  if [[ "${1:-}" == "--all" ]] || [[ "${1:-}" == "-a" ]]; then
    prune_all=true
  fi

  header "Pruning work-lab containers"

  # Find stopped work-lab containers
  local stopped_containers=()
  local cid cname

  while IFS='|' read -r cid cname; do
    [[ -z "$cid" ]] && continue
    stopped_containers+=("$cid|$cname")
  done < <(docker ps -a --filter "label=work-lab.container=true" --filter "status=exited" \
    --format "{{.ID}}|{{.Names}}" 2>/dev/null)

  # Also check legacy containers
  while IFS='|' read -r cid cname local_folder; do
    [[ -z "$cid" ]] && continue
    # Only include if it looks like a work-lab container
    if [[ "$local_folder" == *"/work-lab"* ]] || [[ "$local_folder" == *"libexec"* ]]; then
      stopped_containers+=("$cid|$cname")
    fi
  done < <(docker ps -a --filter "label=devcontainer.local_folder" --filter "status=exited" \
    --format "{{.ID}}|{{.Names}}|{{.Label \"devcontainer.local_folder\"}}" 2>/dev/null)

  if [[ ${#stopped_containers[@]} -eq 0 ]]; then
    status_ok "No stopped work-lab containers"
  else
    for entry in "${stopped_containers[@]}"; do
      IFS='|' read -r cid cname <<< "$entry"
      activity "Removing $cname (${cid:0:12})..."
      if docker rm "$cid" &>/dev/null; then
        status_ok "Removed $cname"
      else
        status_warn "Failed to remove $cname"
      fi
    done
  fi

  if [[ "$prune_all" == "true" ]]; then
    echo ""
    header "Pruning unused images"

    # Remove dangling images
    local dangling
    dangling=$(docker images -f "dangling=true" -q 2>/dev/null)
    if [[ -n "$dangling" ]]; then
      activity "Removing dangling images..."
      docker image prune -f &>/dev/null
      status_ok "Removed dangling images"
    else
      status_ok "No dangling images"
    fi

    # Remove old work-lab images (keep latest)
    local old_images
    old_images=$(docker images "ghcr.io/modern-tooling/work-lab" --format "{{.ID}}" 2>/dev/null | tail -n +2)
    if [[ -n "$old_images" ]]; then
      activity "Removing old work-lab images..."
      echo "$old_images" | xargs -r docker rmi &>/dev/null || true
      status_ok "Removed old work-lab images"
    fi
  fi

  echo ""
  print_pass "Prune complete"
}

# Show forwarded ports for work-lab and paired devcontainer
cmd_ports() {
  require_host

  local project_root
  project_root=$(find_git_root 2>/dev/null)

  header "Forwarded ports"

  local found_ports=false

  # Check work-lab container ports (docker -p published ports)
  local wl_container_id
  wl_container_id=$(find_container 2>/dev/null)
  if [[ -n "$wl_container_id" ]]; then
    local wl_ports
    wl_ports=$(docker port "$wl_container_id" 2>/dev/null)
    if [[ -n "$wl_ports" ]]; then
      subheader "work-lab"
      while IFS= read -r line; do
        local container_port host_port
        container_port=$(echo "$line" | cut -d' ' -f1 | cut -d'/' -f1)
        host_port=$(echo "$line" | awk -F':' '{print $NF}')
        printf "  ${C_COMMAND}%s${C_RESET} ${C_DIM}→${C_RESET} ${C_ACCENT}localhost:%s${C_RESET}\n" "$container_port" "$host_port"
      done <<< "$wl_ports"
      found_ports=true
    fi
  fi

  # Check paired devcontainer ports (sidecar mode)
  if [[ -n "$project_root" ]]; then
    local dc_container_id
    dc_container_id=$(docker ps --filter "label=devcontainer.local_folder=$project_root" \
      --format '{{.ID}}' 2>/dev/null | head -1)

    # Check docker published ports first
    if [[ -n "$dc_container_id" ]]; then
      local dc_ports
      dc_ports=$(docker port "$dc_container_id" 2>/dev/null)
      if [[ -n "$dc_ports" ]]; then
        [[ "$found_ports" == "true" ]] && echo ""
        subheader "devcontainer (published)"
        while IFS= read -r line; do
          local container_port host_port
          container_port=$(echo "$line" | cut -d' ' -f1 | cut -d'/' -f1)
          host_port=$(echo "$line" | awk -F':' '{print $NF}')
          printf "  ${C_COMMAND}%s${C_RESET} ${C_DIM}→${C_RESET} ${C_ACCENT}localhost:%s${C_RESET}\n" "$container_port" "$host_port"
        done <<< "$dc_ports"
        found_ports=true
      fi
    fi

    # Check devcontainer.json for forwardPorts configuration
    local dc_config=""
    if [[ -f "$project_root/.devcontainer/devcontainer.json" ]]; then
      dc_config="$project_root/.devcontainer/devcontainer.json"
    elif [[ -f "$project_root/.devcontainer.json" ]]; then
      dc_config="$project_root/.devcontainer.json"
    fi

    if [[ -n "$dc_config" ]] && command -v jq &>/dev/null; then
      local forward_ports
      # Extract forwardPorts array, handling both number and string formats
      # Use grep to strip comments first (devcontainer.json allows // comments)
      forward_ports=$(grep -v '^\s*//' "$dc_config" 2>/dev/null | jq -r '.forwardPorts // [] | .[]' 2>/dev/null | grep -v '^$') || true
      if [[ -n "$forward_ports" ]]; then
        [[ "$found_ports" == "true" ]] && echo ""
        subheader "devcontainer (forwardPorts)"
        while IFS= read -r port; do
          # Handle "host:container" format or just port number
          if [[ "$port" == *:* ]]; then
            local host_port container_port
            host_port="${port%%:*}"
            container_port="${port##*:}"
            printf "  ${C_COMMAND}%s${C_RESET} ${C_DIM}→${C_RESET} ${C_ACCENT}localhost:%s${C_RESET}\n" "$container_port" "$host_port"
          else
            printf "  ${C_COMMAND}%s${C_RESET} ${C_DIM}→${C_RESET} ${C_ACCENT}localhost:%s${C_RESET}\n" "$port" "$port"
          fi
        done <<< "$forward_ports"
        found_ports=true
        detail "Ports forwarded when attached via VS Code"
      fi
    fi
  fi

  if [[ "$found_ports" == "false" ]]; then
    status_info "No ports configured"
    if [[ -n "$project_root" ]] && has_devcontainer "$project_root"; then
      detail "Add forwardPorts to devcontainer.json"
    fi
  fi
}

# Run command in associated project devcontainer (from inside work-lab or host)
cmd_dc() {
  local cmd="${1:-}"
  shift 2>/dev/null || true

  if [[ -z "$cmd" ]]; then
    echo "Usage: work-lab dc <command> [args...]"
    echo ""
    echo "Run a command in the project's devcontainer."
    echo ""
    echo "Examples:"
    printf "  ${C_COMMAND}work-lab dc npm test${C_RESET}        Run tests in devcontainer\n"
    printf "  ${C_COMMAND}work-lab dc make build${C_RESET}      Build project in devcontainer\n"
    printf "  ${C_COMMAND}work-lab dc bash${C_RESET}            Interactive shell in devcontainer\n"
    return 0
  fi

  # When inside work-lab, use SSH tunnel instead of docker exec
  if is_inside_container; then
    local project_path="/workspaces/project"
    if [[ ! -d "$project_path" ]]; then
      status_fail "Project not mounted at /workspaces/project"
      fail_exit
    fi

    # Check if SSH tunnel is configured
    if [[ -f "$project_path/.work-lab/ssh-key" ]] && [[ -f "$project_path/.work-lab/ip" ]]; then
      # Use dc-ssh to run command via SSH tunnel
      exec dc-ssh "$cmd" "$@"
    else
      status_fail "SSH tunnel not configured"
      echo ""
      action "From HOST, run:"
      printf "  ${C_COMMAND}wl mux${C_RESET}    (configures tunnel automatically)\n"
      echo ""
      tip "After setup: ${C_COMMAND}prefix + S${C_TIP} in tmux, or ${C_COMMAND}wl dc <cmd>${C_TIP}"
      fail_exit
    fi
  fi

  # On host: use docker exec
  local project_path project_name
  project_path=$(find_git_root)
  if [[ -z "$project_path" ]]; then
    status_fail "Not in a git repository"
    fail_exit
  fi
  project_name=$(basename "$project_path")

  # Also ensure SSH tunnel is set up for future use from inside work-lab
  ensure_ssh_tunnel "$project_path" 2>/dev/null || true

  # Find the project's devcontainer using path-matching
  local dc_id=""

  # Try exact path match first, then project name match
  while IFS= read -r cid; do
    [[ -z "$cid" ]] && continue

    # Get container info
    local cname local_folder
    cname=$(docker inspect --format '{{.Name}}' "$cid" 2>/dev/null | tr -d '/')
    local_folder=$(docker inspect --format '{{index .Config.Labels "devcontainer.local_folder"}}' "$cid" 2>/dev/null)

    # Skip work-lab containers
    if [[ "$cname" == *"work-lab"* ]]; then
      continue
    fi

    # Check for exact path match
    if [[ "$local_folder" == "$project_path" ]]; then
      dc_id="$cid"
      break
    fi

    # Check for project name match (same basename)
    if [[ -n "$local_folder" ]]; then
      local folder_name
      folder_name=$(basename "$local_folder")
      if [[ "$folder_name" == "$project_name" ]]; then
        dc_id="$cid"
        break
      fi
    fi
  done < <(docker ps --filter "label=devcontainer.local_folder" --format '{{.ID}}' 2>/dev/null)

  if [[ -z "$dc_id" ]]; then
    status_fail "Project devcontainer not running"
    action "Start project devcontainer first"
    if is_inside_container; then
      action "From host: ${C_COMMAND}devcontainer up${C_ACTION}"
    fi
    fail_exit
  fi

  # Find the default user for this devcontainer (common defaults: vscode, node, root)
  local dc_user
  dc_user=$(docker inspect --format '{{.Config.User}}' "$dc_id" 2>/dev/null)
  if [[ -z "$dc_user" ]] || [[ "$dc_user" == "root" ]]; then
    # Try to find a non-root user
    for try_user in vscode node; do
      if docker exec "$dc_id" id "$try_user" &>/dev/null; then
        dc_user="$try_user"
        break
      fi
    done
  fi
  dc_user="${dc_user:-root}"

  # Find workspace directory inside the container (try common patterns)
  local dc_workdir=""
  for try_dir in "/workspaces/$project_name" "/workspace" "/workspaces" "/app" "/"; do
    if docker exec "$dc_id" test -d "$try_dir" 2>/dev/null; then
      dc_workdir="$try_dir"
      break
    fi
  done
  dc_workdir="${dc_workdir:-/}"

  # Build exec flags
  local -a exec_flags=("-u" "$dc_user" "-w" "$dc_workdir")
  if [[ -t 0 ]]; then
    exec_flags+=("-it")
  else
    exec_flags+=("-i")
  fi

  # Run the command
  if [[ "$cmd" == "bash" ]] || [[ "$cmd" == "sh" ]] || [[ "$cmd" == "zsh" ]]; then
    docker exec "${exec_flags[@]}" "$dc_id" "$cmd" "$@"
  else
    docker exec "${exec_flags[@]}" "$dc_id" "$cmd" "$@"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Update checking
# ─────────────────────────────────────────────────────────────────────────────
UPDATE_CHECK_CACHE_DIR="$HOME/.cache/work-lab"
UPDATE_CHECK_CACHE_FILE="$UPDATE_CHECK_CACHE_DIR/update-check"
UPDATE_CHECK_CACHE_TTL=$((24 * 60 * 60))  # 24 hours in seconds

# Compare two semantic versions: returns 0 if v1 < v2, 1 otherwise
# Strips leading 'v' from both versions
_version_lt() {
  local v1="${1#v}" v2="${2#v}"
  local IFS='.'
  # shellcheck disable=SC2206
  local i v1_parts=($v1) v2_parts=($v2)
  for ((i = 0; i < 3; i++)); do
    local p1="${v1_parts[i]:-0}" p2="${v2_parts[i]:-0}"
    if (( p1 < p2 )); then
      return 0
    elif (( p1 > p2 )); then
      return 1
    fi
  done
  return 1  # equal, not less than
}

# Fetch latest version from GitHub (returns version string without 'v' prefix)
_fetch_latest_version() {
  local url="https://api.github.com/repos/modern-tooling/work-lab/releases/latest"
  local response tag_name

  if ! command -v curl &>/dev/null; then
    return 1
  fi

  response=$(curl -sL --max-time 5 "$url" 2>/dev/null) || return 1

  if ! command -v jq &>/dev/null; then
    # fallback: parse with grep/sed
    tag_name=$(echo "$response" | grep -o '"tag_name"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"v\?\([^"]*\)".*/\1/')
  else
    tag_name=$(echo "$response" | jq -r '.tag_name // empty' 2>/dev/null)
  fi

  if [[ -z "$tag_name" ]]; then
    return 1
  fi

  # strip leading 'v' if present
  echo "${tag_name#v}"
}

# Get cached latest version (returns empty if cache expired or missing)
_get_cached_version() {
  if [[ ! -f "$UPDATE_CHECK_CACHE_FILE" ]]; then
    return 1
  fi

  local cache_time cached_version now
  cache_time=$(head -1 "$UPDATE_CHECK_CACHE_FILE" 2>/dev/null) || return 1
  cached_version=$(tail -1 "$UPDATE_CHECK_CACHE_FILE" 2>/dev/null) || return 1
  now=$(date +%s)

  if (( now - cache_time > UPDATE_CHECK_CACHE_TTL )); then
    return 1  # cache expired
  fi

  echo "$cached_version"
}

# Save version to cache
_save_cached_version() {
  local version="$1"
  mkdir -p "$UPDATE_CHECK_CACHE_DIR"
  printf '%s\n%s\n' "$(date +%s)" "$version" > "$UPDATE_CHECK_CACHE_FILE"
}

# Check for updates (uses cache, returns 0 if update available)
# Sets UPDATE_LATEST_VERSION variable
check_for_update() {
  local latest

  # try cache first
  latest=$(_get_cached_version)
  if [[ -z "$latest" ]]; then
    # cache miss or expired, fetch from GitHub
    latest=$(_fetch_latest_version) || return 1
    _save_cached_version "$latest"
  fi

  UPDATE_LATEST_VERSION="$latest"

  # compare versions
  if _version_lt "$VERSION" "$latest"; then
    return 0  # update available
  fi
  return 1  # up to date
}

cmd_doctor() {
  local fix_mode=false
  if [[ "${1:-}" == "--fix" ]]; then
    fix_mode=true
  fi

  # Inside container: show container-specific diagnostics
  if is_inside_container; then
    banner "work-lab doctor (inside container)"

    header "Environment"
    status_ok "Running inside work-lab container"

    # Check workspace mount
    if [[ -d /workspaces/project ]]; then
      status_ok "Project mounted at /workspaces/project"
      if [[ -d /workspaces/project/.git ]]; then
        local proj_name
        proj_name=$(basename /workspaces/project)
        detail "Project: $proj_name"
      fi
    else
      status_fail "No project mounted at /workspaces/project"
    fi

    # Check multiplexer
    header "Tools"
    if command -v tmux &>/dev/null; then
      status_ok "tmux: $(tmux -V 2>/dev/null || echo 'installed')"
    else
      status_warn "tmux: not found"
    fi
    if command -v zellij &>/dev/null; then
      status_ok "zellij: $(zellij --version 2>/dev/null || echo 'installed')"
    fi

    # Check SSH tunnel to devcontainer
    header "Sidecar Connection"
    if [[ -f /workspaces/project/.work-lab/ssh-key ]] && [[ -f /workspaces/project/.work-lab/ip ]]; then
      local dc_ip dc_user
      dc_ip=$(cat /workspaces/project/.work-lab/ip 2>/dev/null)
      dc_user=$(cat /workspaces/project/.work-lab/user 2>/dev/null || echo "vscode")
      status_ok "SSH tunnel configured"
      detail "Target: $dc_user@$dc_ip"
      tip "Connect to devcontainer: ${C_COMMAND}dc-ssh${C_TIP}"
    else
      status_info "No SSH tunnel configured"
      detail "Project may not have a devcontainer, or tunnel not set up"
    fi

    echo ""
    print_pass "Inside container. Run 'work-lab doctor' on host for full diagnostics."
    return 0
  fi

  local container_id config_dir errors=0 fixes_applied=0
  local mount_spec src_path tgt_path

  if [[ "$fix_mode" == "true" ]]; then
    banner "work-lab doctor --fix"
  else
    banner "work-lab doctor"
  fi

  # check for updates first (most critical info)
  header "Updates"
  if check_for_update; then
    status_warn "v$UPDATE_LATEST_VERSION available (current: v$VERSION)"
    # show appropriate upgrade instructions based on installation method
    if [[ "$REPO_DIR" == */Cellar/work-lab/* ]]; then
      action "Upgrade: ${C_COMMAND}brew upgrade work-lab${C_ACTION}"
    else
      action "Releases: ${C_COMMAND}https://github.com/modern-tooling/work-lab/releases${C_ACTION}"
    fi
  else
    status_ok "up to date (v$VERSION)"
  fi

  # check installation
  header "Installation"
  if [[ "$REPO_DIR" == */Cellar/work-lab/* ]]; then
    status_ok "Homebrew"
  elif [[ "$REPO_DIR" == "$HOME/.local/share/work-lab" ]]; then
    status_ok "\$HOME/.local/share/work-lab"
  else
    status_ok "$(basename "$REPO_DIR")"
    detail "$REPO_DIR"
  fi

  # check for wl alias/command
  # Note: command -v doesn't see aliases, so check shell configs too
  local wl_found=false
  if command -v wl &>/dev/null; then
    wl_found=true
  elif grep -q "alias wl=" "$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.bash_aliases" 2>/dev/null; then
    wl_found=true
  fi
  if [[ "$wl_found" == "true" ]]; then
    status_ok "wl command available"
  else
    status_info "wl alias not set"
    tip "Add to shell: ${C_COMMAND}alias wl='work-lab'${C_TIP}"
  fi

  # check dependencies
  header "Dependencies"
  if command -v docker &>/dev/null; then
    status_ok "docker: $(docker --version 2>/dev/null | head -n 1 || echo 'installed')"
    # Check if docker daemon is running
    if docker info &>/dev/null; then
      status_ok "docker daemon: running"
    else
      status_fail "docker daemon: not running"
      action "Start Docker Desktop or ${C_COMMAND}dockerd${C_ACTION}"
      ((errors++)) || true
    fi
  else
    status_fail "docker: not found"
    action "Install: ${C_COMMAND}https://docs.docker.com/get-docker/${C_ACTION}"
    ((errors++)) || true
  fi
  if command -v devcontainer &>/dev/null; then
    status_ok "devcontainer CLI: $(devcontainer --version 2>/dev/null || echo 'installed')"
  else
    if [[ "$fix_mode" == "true" ]] && command -v npm &>/dev/null; then
      status_warn "devcontainer CLI: not found"
      activity "Installing devcontainer CLI..."
      if npm install -g @devcontainers/cli 2>/dev/null; then
        status_ok "devcontainer CLI: installed"
        ((fixes_applied++)) || true
      else
        status_fail "devcontainer CLI: install failed"
        action "Manual install: ${C_COMMAND}npm install -g @devcontainers/cli${C_ACTION}"
        ((errors++)) || true
      fi
    else
      status_fail "devcontainer CLI: not found"
      action "Install: ${C_COMMAND}npm install -g @devcontainers/cli${C_ACTION}"
      ((errors++)) || true
    fi
  fi

  # check container status
  header "Container"
  if command -v docker &>/dev/null && docker info &>/dev/null; then
    container_id=$(find_container)
    if [[ -n "$container_id" ]]; then
      status_ok "running (id: ${container_id:0:12})"
    else
      status_info "not running"
      action "Run ${C_COMMAND}work-lab start${C_ACTION}"
    fi
  else
    status_skip "cannot check (docker not available)"
  fi

  # check for stale containers (local_folder path no longer exists)
  header "Stale containers"
  if command -v docker &>/dev/null && docker info &>/dev/null; then
    local stale_containers=() cid local_folder cname
    while IFS='|' read -r cid cname local_folder; do
      [[ -z "$cid" ]] && continue
      # check if the local_folder path exists
      if [[ -n "$local_folder" ]] && [[ ! -d "$local_folder" ]]; then
        stale_containers+=("$cid|$cname|$local_folder")
      fi
    done < <(docker ps -a --filter "label=devcontainer.local_folder" \
      --format "{{.ID}}|{{.Names}}|{{.Label \"devcontainer.local_folder\"}}" 2>/dev/null)

    if (( ${#stale_containers[@]} == 0 )); then
      status_ok "none found"
    else
      for entry in "${stale_containers[@]}"; do
        IFS='|' read -r cid cname local_folder <<< "$entry"
        if [[ "$fix_mode" == "true" ]]; then
          status_warn "removing stale: ${cname} (${cid:0:12})"
          detail "path no longer exists: $local_folder"
          if docker rm -f "$cid" &>/dev/null; then
            status_ok "removed: ${cname}"
            ((fixes_applied++)) || true
          else
            status_fail "failed to remove: ${cname}"
            ((errors++)) || true
          fi
        else
          status_warn "stale: ${cname} (${cid:0:12})"
          detail "path no longer exists: $local_folder"
          action "Remove: ${C_COMMAND}docker rm -f ${cid:0:12}${C_ACTION}"
          ((errors++)) || true
        fi
      done
    fi
  else
    status_skip "cannot check (docker not available)"
  fi

  # check Docker image for updates
  header "Docker image"
  if command -v docker &>/dev/null && docker info &>/dev/null; then
    # Get local image info
    local local_digest local_created
    local_digest=$(docker images --digests --format "{{.Digest}}" "$WORK_LAB_IMAGE" 2>/dev/null | head -1)
    local_created=$(docker images --format "{{.CreatedSince}}" "$WORK_LAB_IMAGE" 2>/dev/null | head -1)

    if [[ -z "$local_digest" ]]; then
      status_info "not pulled yet"
      action "Run ${C_COMMAND}work-lab start${C_ACTION} to pull image"
    elif [[ "$fix_mode" == "true" ]]; then
      # --fix mode: check for updates by pulling
      activity "checking for updates..."
      local pull_output
      if pull_output=$(docker pull "$WORK_LAB_IMAGE" 2>&1); then
        if echo "$pull_output" | grep -q "Image is up to date"; then
          status_ok "up to date"
          detail "$WORK_LAB_IMAGE"
        elif echo "$pull_output" | grep -q "Downloaded newer image\|Pull complete"; then
          status_ok "updated to latest"
          detail "New image pulled"
          if [[ -n "$(find_container)" ]]; then
            action "Rebuild: ${C_COMMAND}work-lab rebuild${C_ACTION}"
          fi
          ((fixes_applied++)) || true
        else
          status_ok "checked"
          detail "$WORK_LAB_IMAGE"
        fi
      else
        status_warn "could not check for updates"
        detail "Network or registry issue"
      fi
    else
      # Normal mode: just show current image info
      status_ok "present (pulled $local_created)"
      detail "$WORK_LAB_IMAGE"
      tip "Check for updates: ${C_COMMAND}work-lab doctor --fix${C_TIP}"
    fi
  else
    status_skip "cannot check (docker not available)"
  fi

  # show and validate configuration
  header "Configuration"
  config_dir="$HOME/.config/work-lab"
  if [[ -f "$config_dir/config" ]]; then
    status_ok "config file: $config_dir/config"
  else
    status_info "config file: not found (using defaults)"
  fi
  kv "WORK_LAB_IMAGE=" "$WORK_LAB_IMAGE"

  # check current project (git repo)
  header "Current project"
  local git_root
  git_root=$(find_git_root)
  if [[ -n "$git_root" ]]; then
    status_ok "$(get_project_name "$git_root")"
    detail "$git_root"
  else
    status_warn "not in a git repository"
    action "From git project: ${C_COMMAND}work-lab start${C_ACTION}"
  fi

  # validate configured mounts
  header "Configured mounts"
  if (( ${#WORK_LAB_MOUNTS_RO[@]} == 0 && ${#WORK_LAB_MOUNTS_RW[@]} == 0 )); then
    status_info "none configured (optional)"
  else
    # Check read-only mounts
    if (( ${#WORK_LAB_MOUNTS_RO[@]} > 0 )); then
      for mount_spec in "${WORK_LAB_MOUNTS_RO[@]}"; do
        if [[ "$mount_spec" != *:* ]]; then
          status_fail "invalid format (missing colon): $mount_spec"
          ((errors++)) || true
          continue
        fi
        src_path="${mount_spec%%:*}"
        tgt_path="${mount_spec#*:}"
        # Expand ~ and $HOME
        src_path="${src_path/#\~/$HOME}"
        src_path="${src_path//\$HOME/$HOME}"
        if [[ -e "$src_path" ]]; then
          if [[ -r "$src_path" ]]; then
            status_ok "$src_path ${ICON_ARROW} $tgt_path (ro)"
          else
            status_fail "$src_path ${ICON_ARROW} $tgt_path (ro) - not readable"
            ((errors++)) || true
          fi
        else
          status_warn "$src_path ${ICON_ARROW} $tgt_path (ro) - source not found"
        fi
      done
    fi
    # Check read-write mounts
    if (( ${#WORK_LAB_MOUNTS_RW[@]} > 0 )); then
      for mount_spec in "${WORK_LAB_MOUNTS_RW[@]}"; do
        if [[ "$mount_spec" != *:* ]]; then
          status_fail "invalid format (missing colon): $mount_spec"
          ((errors++)) || true
          continue
        fi
        src_path="${mount_spec%%:*}"
        tgt_path="${mount_spec#*:}"
        # Expand ~ and $HOME
        src_path="${src_path/#\~/$HOME}"
        src_path="${src_path//\$HOME/$HOME}"
        if [[ -e "$src_path" ]]; then
          if [[ -r "$src_path" && -w "$src_path" ]]; then
            status_ok "$src_path ${ICON_ARROW} $tgt_path (rw)"
          else
            status_fail "$src_path ${ICON_ARROW} $tgt_path (rw) - not readable/writable"
            ((errors++)) || true
          fi
        else
          status_warn "$src_path ${ICON_ARROW} $tgt_path (rw) - source not found"
        fi
      done
    fi
  fi

  # check user hooks
  header "Lifecycle hooks"
  if [[ -d "$config_dir" ]]; then
    if [[ -f "$config_dir/post-create.sh" ]]; then
      if [[ -x "$config_dir/post-create.sh" ]] || head -1 "$config_dir/post-create.sh" | grep -q '^#!'; then
        status_ok "post-create.sh"
      else
        status_warn "post-create.sh (missing shebang or not executable)"
      fi
    else
      status_info "post-create.sh (not found)"
    fi
    if [[ -f "$config_dir/post-start.sh" ]]; then
      if [[ -x "$config_dir/post-start.sh" ]] || head -1 "$config_dir/post-start.sh" | grep -q '^#!'; then
        status_ok "post-start.sh"
      else
        status_warn "post-start.sh (missing shebang or not executable)"
      fi
    else
      status_info "post-start.sh (not found)"
    fi
  else
    status_info "\$HOME/.config/work-lab/ not found (optional)"
  fi

  # mode detection and sidecar status
  header "Mode"
  if [[ -n "$git_root" ]]; then
    if has_devcontainer "$git_root"; then
      status_info "Sidecar mode"
      detail "Project has devcontainer - work-lab runs alongside it"

      # Check if project devcontainer is running
      if command -v docker &>/dev/null && docker info &>/dev/null; then
        local dc_id
        dc_id=$(docker ps --filter "label=devcontainer.local_folder=$git_root" \
          --format "{{.ID}}" 2>/dev/null | head -n 1)

        if [[ -n "$dc_id" ]]; then
          status_ok "project devcontainer: running (${dc_id:0:12})"
          printf "  ${C_DIM}To run in paired devcontainer:${C_RESET} ${C_COMMAND}wl dc <cmd>${C_RESET}\n"

          # check if SSH tunnel credentials exist (shared filesystem approach)
          if check_project_ssh_tunnel "$git_root"; then
            status_ok "SSH tunnel: configured"
            tip "SSH to devcontainer: ${C_COMMAND}prefix + S${C_TIP} in tmux"
          else
            if [[ "$fix_mode" == "true" ]]; then
              status_info "SSH tunnel: not configured"
              activity "Setting up SSH tunnel..."
              if ensure_ssh_tunnel "$git_root" 2>/dev/null; then
                if check_project_ssh_tunnel "$git_root"; then
                  status_ok "SSH tunnel: configured"
                  ((fixes_applied++)) || true
                else
                  status_warn "SSH tunnel: could not configure (devcontainer may lack sshd)"
                fi
              else
                status_warn "SSH tunnel: setup failed"
              fi
            else
              status_info "SSH tunnel: not configured"
              action "Setup: ${C_COMMAND}docs/ssh-tunneling.md${C_ACTION}"
            fi
          fi
        else
          status_warn "project devcontainer: not running"
          action "Start: ${C_COMMAND}devcontainer up --workspace-folder $git_root${C_ACTION}"
        fi
      fi
    else
      status_info "Standalone mode"
      detail "work-lab provides the development environment"
    fi
  else
    status_skip "cannot determine (not in a git repo)"
  fi

  # summary
  echo ""
  separator
  if [[ "$fix_mode" == "true" ]] && (( fixes_applied > 0 )); then
    print_pass "Applied $fixes_applied fix(es)."
  fi
  if (( errors > 0 )); then
    print_fail "Found $errors error(s). Fix them before running 'work-lab start'."
    if [[ "$fix_mode" != "true" ]]; then
      action "Auto-fix: ${C_COMMAND}work-lab doctor --fix${C_ACTION}"
    fi
    INTENTIONAL_EXIT=1
    return 1
  else
    print_pass "All checks passed. Ready to run 'work-lab start'."
    return 0
  fi
}

# Main
case "${1:-}" in
  start|up)
    cmd_up
    ;;
  shell)
    shift
    cmd_shell "$@"
    ;;
  mux|tmux)
    shift
    cmd_mux "$@"
    ;;
  prune)
    shift
    cmd_prune "$@"
    ;;
  ports)
    cmd_ports
    ;;
  stop|down)
    cmd_stop
    ;;
  rebuild)
    cmd_rebuild
    ;;
  ps)
    cmd_ps
    ;;
  dc)
    shift
    cmd_dc "$@"
    ;;
  doctor)
    shift
    cmd_doctor "$@"
    ;;
  version|--version|-v)
    cmd_version
    ;;
  release-notes)
    cmd_release_notes
    ;;
  help|--help|-h)
    usage
    ;;
  "")
    usage
    fail_exit
    ;;
  *)
    echo "Unknown command: $1"
    usage
    fail_exit
    ;;
esac
