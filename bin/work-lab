#!/usr/bin/env bash
# work-lab
# Copyright (c) 2026 Ryan Snodgrass. MIT License.
# A small convenience script for managing the work-lab devcontainer.
# This script is OPTIONAL. You can use the devcontainer CLI or VS Code directly.

set -Eeuo pipefail

VERSION="0.1.6"

# shellcheck disable=SC2155
readonly SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd -P)"
# shellcheck disable=SC2155
readonly REPO_DIR="$(dirname -- "$SCRIPT_DIR")"

# error handler for debugging (only fires on unexpected errors)
_err_handler() {
  local code=$?
  # Skip if this is an intentional exit (INTENTIONAL_EXIT is set)
  [[ "${INTENTIONAL_EXIT:-0}" -eq 1 ]] && return 0
  printf "Error at line %d: exit %d\n" "$1" "$code" >&2
}
trap '_err_handler "$LINENO"' ERR

# Helper for intentional non-zero exits (avoids triggering error trap)
fail_exit() {
  INTENTIONAL_EXIT=1
  exit "${1:-1}"
}

# Source the styling library
# shellcheck source=../lib/style.sh
source "$REPO_DIR/lib/style.sh"

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────
# Defaults (can be overridden by ~/.config/work-lab/config or environment)
: "${WORK_LAB_IMAGE:=ghcr.io/modern-tooling/work-lab:latest}"
: "${WORK_LAB_MUX:=tmux}"  # terminal multiplexer: tmux or zellij

# Additional mounts (arrays, set in config file)
# Format: "source:target" - will be mounted read-only or read-write
WORK_LAB_MOUNTS_RO=(
  # Claude config (settings, API keys) - read-only for safety
  "$HOME/.claude:/home/worklab/.claude"
)
WORK_LAB_MOUNTS_RW=()    # read-write mounts

# Source user config if present (can override defaults above)
config_file="$HOME/.config/work-lab/config"
if [[ -f "$config_file" ]]; then
  # shellcheck source=/dev/null
  source "$config_file"
fi

# Export for devcontainer.json ${localEnv:...} substitution
export WORK_LAB_IMAGE

# ─────────────────────────────────────────────────────────────────────────────
# Container detection
# ─────────────────────────────────────────────────────────────────────────────
# Check if running inside work-lab container
is_inside_container() {
  [[ -f /workspaces/work-lab/.devcontainer/devcontainer.json ]] || \
  [[ "${WORK_LAB_CONTAINER:-}" == "1" ]]
}

# Require running outside container (for host-only commands)
require_host() {
  if is_inside_container; then
    status_fail "This command must be run on the host, not inside work-lab"
    hint "exit the container and run from your host terminal"
    fail_exit
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Project detection
# ─────────────────────────────────────────────────────────────────────────────
# Find the git root of the current directory (or empty if not in a git repo)
find_git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

# Get the project name from the git root directory
get_project_name() {
  local git_root="$1"
  basename "$git_root"
}

# Build mount flags for devcontainer up
# Note: devcontainer CLI requires --mount=VALUE format (with equals sign)
# Read-only not directly supported by devcontainer CLI, but we track intent
build_mount_flags() {
  local flags=()
  local mount_spec src_path tgt_path

  # Add read-only mounts (guard against empty array for Bash < 4.4)
  # Note: devcontainer CLI doesn't support readonly flag, so mounts are rw
  if (( ${#WORK_LAB_MOUNTS_RO[@]} > 0 )); then
    for mount_spec in "${WORK_LAB_MOUNTS_RO[@]}"; do
      # Validate format: must contain colon separator
      if [[ "$mount_spec" != *:* ]]; then
        status_fail "invalid mount spec (missing colon): $mount_spec" >&2
        continue
      fi
      src_path="${mount_spec%%:*}"
      tgt_path="${mount_spec#*:}"
      # Expand ~ and $HOME
      src_path="${src_path/#\~/$HOME}"
      src_path="${src_path//\$HOME/$HOME}"
      if [[ -e "$src_path" ]]; then
        flags+=("--mount=type=bind,source=$src_path,target=$tgt_path")
        status_ok "$src_path ${ICON_ARROW} $tgt_path (ro)" >&2
      else
        status_warn "skipping (not found): $src_path" >&2
      fi
    done
  fi

  # Add read-write mounts (guard against empty array for Bash < 4.4)
  if (( ${#WORK_LAB_MOUNTS_RW[@]} > 0 )); then
    for mount_spec in "${WORK_LAB_MOUNTS_RW[@]}"; do
      # Validate format: must contain colon separator
      if [[ "$mount_spec" != *:* ]]; then
        status_fail "invalid mount spec (missing colon): $mount_spec" >&2
        continue
      fi
      src_path="${mount_spec%%:*}"
      tgt_path="${mount_spec#*:}"
      # Expand ~ and $HOME
      src_path="${src_path/#\~/$HOME}"
      src_path="${src_path//\$HOME/$HOME}"
      if [[ -e "$src_path" ]]; then
        flags+=("--mount=type=bind,source=$src_path,target=$tgt_path")
        status_ok "$src_path ${ICON_ARROW} $tgt_path (rw)" >&2
      else
        status_warn "skipping (not found): $src_path" >&2
      fi
    done
  fi

  # Output flags (guard against empty array)
  if (( ${#flags[@]} > 0 )); then
    printf '%s\n' "${flags[@]}"
  fi
}

usage() {
  echo ""
  print_bold "work-lab"
  print_dim "containerized environment for AI coding agents"
  echo ""
  print_accent "Usage:"
  echo "  work-lab <command>"
  echo ""
  print_accent "Commands:"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "up" "Start work-lab for the current git project"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "mux" "Attach to tmux session ${C_DIM}(recommended)${C_RESET}"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "shell" "Run a one-off shell command"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "stop" "Stop the container"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "ps" "List running work-lab containers"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "dc <cmd>" "Run command in project's devcontainer"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "doctor" "Check environment and configuration"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "upgrade" "Upgrade to latest version"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "version" "Show version information"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "release-notes" "Show release notes"
  printf "  ${C_COMMAND}%-14s${C_RESET} %s\n" "help" "Show this message"
  echo ""
  print_accent "Workflow:"
  print_dim "  1. wl up      Start work-lab for your project"
  print_dim "  2. wl mux     Enter tmux session (persistent, multiple windows)"
  echo ""
  print_dim "https://github.com/modern-tooling/work-lab"
  echo ""
}

cmd_version() {
  printf "${C_BOLD}work-lab${C_RESET} ${C_COMMAND}%s${C_RESET}\n" "$VERSION"
}

cmd_release_notes() {
  local url="https://api.github.com/repos/modern-tooling/work-lab/releases"
  local releases

  header "work-lab release notes"
  printf "  ${C_LABEL}current${C_RESET}  ${C_COMMAND}v%s${C_RESET}\n" "$VERSION"

  if ! command -v curl &>/dev/null; then
    print_dim "curl not available"
    hint "https://github.com/modern-tooling/work-lab/releases"
    return
  fi

  releases=$(curl -sL "$url" 2>/dev/null)
  if [[ -z "$releases" ]] || ! echo "$releases" | jq -e '.' &>/dev/null; then
    print_dim "Could not fetch release notes"
    hint "https://github.com/modern-tooling/work-lab/releases"
    return
  fi

  # Helper to strip markdown formatting
  _strip_md() {
    local s="$1"
    s="${s//\`/}"      # backticks
    s="${s//\*\*/}"    # bold markers
    echo "$s"
  }

  # Format and display each release
  local in_code_block=0
  local parsed
  if ! parsed=$(echo "$releases" | jq -r '.[] | "\(.tag_name)\n\(.body)\n---END---"' 2>/dev/null); then
    print_dim "No releases found"
    hint "https://github.com/modern-tooling/work-lab/releases"
    return 0
  fi
  echo "$parsed" | while IFS= read -r line; do
    # Version header
    if [[ "$line" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      local tag="$line"
      echo ""
      printf "${C_DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C_RESET}\n"
      if [[ "$tag" == "v$VERSION" ]]; then
        printf "${C_BOLD}${C_PRIMARY}%s${C_RESET}  ${C_PASS}[current]${C_RESET}\n" "$tag"
      else
        printf "${C_BOLD}${C_PRIMARY}%s${C_RESET}\n" "$tag"
      fi
      printf "${C_DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${C_RESET}\n"
      in_code_block=0
    # Section end marker
    elif [[ "$line" == "---END---" ]]; then
      continue
    # Code block toggle
    elif [[ "$line" == '```'* ]]; then
      in_code_block=$((1 - in_code_block))
      continue
    # Inside code block - print dimmed with indent
    elif (( in_code_block )); then
      printf "      ${C_DIM}%s${C_RESET}\n" "$line"
    # H2 headers (## Something) -> Section headers
    elif [[ "$line" =~ ^##[[:space:]](.+)$ ]]; then
      local section="${BASH_REMATCH[1]}"
      section=$(_strip_md "$section")
      # Skip "What's New" - redundant
      [[ "$section" == "What's New" ]] && continue
      printf "\n${C_ACCENT}%s${C_RESET}\n" "${section^^}"
    # H3 headers (### Something) -> Subsection
    elif [[ "$line" =~ ^###[[:space:]](.+)$ ]]; then
      local subsection="${BASH_REMATCH[1]}"
      subsection=$(_strip_md "$subsection")
      printf "\n  ${C_BOLD}%s${C_RESET}\n" "$subsection"
    # Bullet points with bold labels (- **Label**: description)
    elif [[ "$line" =~ ^-[[:space:]]\*\*([^*]+)\*\*:[[:space:]](.+)$ ]]; then
      local label="${BASH_REMATCH[1]}"
      local desc=$(_strip_md "${BASH_REMATCH[2]}")
      printf "    ${C_LABEL}%-18s${C_RESET} %s\n" "$label" "$desc"
    # Bullet points with bold labels (- **Label** description without colon)
    elif [[ "$line" =~ ^-[[:space:]]\*\*([^*]+)\*\*[[:space:]]?(.*)$ ]]; then
      local label="${BASH_REMATCH[1]}"
      local desc=$(_strip_md "${BASH_REMATCH[2]}")
      if [[ -n "$desc" ]]; then
        printf "    ${C_LABEL}%-18s${C_RESET} %s\n" "$label" "$desc"
      else
        printf "    ${C_LABEL}%s${C_RESET}\n" "$label"
      fi
    # Plain bullet points
    elif [[ "$line" =~ ^-[[:space:]](.+)$ ]]; then
      local item=$(_strip_md "${BASH_REMATCH[1]}")
      printf "    • %s\n" "$item"
    # Numbered list items
    elif [[ "$line" =~ ^[0-9]+\.[[:space:]](.+)$ ]]; then
      local item=$(_strip_md "${BASH_REMATCH[1]}")
      printf "    %s\n" "$item"
    # Commit lines (special case: backtick-wrapped hash)
    elif [[ "$line" =~ ^\`([a-f0-9]+)\`[[:space:]](.+)$ ]]; then
      printf "    ${C_WARN}%s${C_RESET}  %s\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
    # Horizontal rules
    elif [[ "$line" == "---" ]]; then
      continue
    # Links (Full Changelog etc)
    elif [[ "$line" =~ ^https:// ]]; then
      printf "    ${C_DIM}%s${C_RESET}\n" "$line"
    # Empty lines
    elif [[ -z "$line" ]]; then
      echo ""
    # Everything else - strip markdown and print
    else
      local clean=$(_strip_md "$line")
      [[ -n "$clean" ]] && printf "  %s\n" "$clean"
    fi
  done
}

# Find the work-lab container (uses devcontainer's label)
find_container() {
  docker ps -q --filter "label=devcontainer.local_folder=$REPO_DIR" 2>/dev/null | head -n 1
}

# List devcontainers grouped by project, showing work-lab + devcontainer pairs
cmd_ps() {
  require_host

  header "Running containers"

  # Get all running devcontainers
  local containers
  containers=$(docker ps --filter "label=devcontainer.local_folder" \
    --format "{{.ID}}|{{.Names}}|{{.Label \"devcontainer.local_folder\"}}|{{.Status}}" 2>/dev/null)

  if [[ -z "$containers" ]]; then
    status_info "none running"
    hint "work-lab up"
    return
  fi

  # Build associative arrays for work-labs and project devcontainers
  # worklabs_for_project stores space-separated container IDs to support multiple sessions
  declare -A worklabs_for_project  # project_path -> "cid1 cid2 ..."
  declare -A devcontainer_for_project  # project_path -> container_id
  declare -A container_name  # container_id -> name
  declare -a projects  # ordered list of projects

  while IFS='|' read -r cid cname local_folder status; do
    container_name["$cid"]="$cname"

    # Check if this is a work-lab container
    if [[ "$local_folder" == *"/work-lab" ]] || [[ "$local_folder" == "$REPO_DIR" ]]; then
      # Find the mounted project path
      local project_mount
      project_mount=$(docker inspect "$cid" --format '{{range .Mounts}}{{if eq .Destination "/workspaces/project"}}{{.Source}}{{end}}{{end}}' 2>/dev/null)
      if [[ -n "$project_mount" ]]; then
        # Append to existing work-labs for this project (space-separated)
        local existing="${worklabs_for_project[$project_mount]:-}"
        if [[ -z "$existing" ]]; then
          worklabs_for_project["$project_mount"]="$cid"
          # Add to projects list if not already there
          if [[ -z "${devcontainer_for_project[$project_mount]:-}" ]]; then
            projects+=("$project_mount")
          fi
        else
          worklabs_for_project["$project_mount"]="$existing $cid"
        fi
      fi
    else
      # It's a project devcontainer
      devcontainer_for_project["$local_folder"]="$cid"
      if [[ -z "${worklabs_for_project[$local_folder]:-}" ]]; then
        projects+=("$local_folder")
      fi
    fi
  done <<< "$containers"

  # Display grouped by project
  local project_count=${#projects[@]}
  if (( project_count == 0 )); then
    status_info "none running"
    hint "work-lab up"
    return
  fi

  for project in "${projects[@]}"; do
    local project_name
    project_name=$(basename "$project")

    printf "\n${C_ACCENT}%s/${C_RESET}\n" "$project_name"

    local wl_ids="${worklabs_for_project[$project]:-}"
    local dc_id="${devcontainer_for_project[$project]:-}"

    # Convert space-separated IDs to array
    local -a wl_array=()
    if [[ -n "$wl_ids" ]]; then
      read -ra wl_array <<< "$wl_ids"
    fi
    local wl_count=${#wl_array[@]}

    if (( wl_count > 0 )) && [[ -n "$dc_id" ]]; then
      # Work-lab(s) + devcontainer running
      if (( wl_count == 1 )); then
        # Single work-lab session
        local wl_id="${wl_array[0]}"
        printf "  ├─ ${C_COMMAND}work-lab${C_RESET}      ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "${wl_id:0:12}" "${container_name[$wl_id]}"
      else
        # Multiple work-lab sessions sharing the same devcontainer
        local session_annotation
        session_annotation=$(printf "${C_ACCENT}(%d sessions)${C_RESET}" "$wl_count")
        printf "  ├─ ${C_COMMAND}work-lab${C_RESET}      %b\n" "$session_annotation"
        local i=0
        for wl_id in "${wl_array[@]}"; do
          ((i++))
          local connector="│"
          if (( i == wl_count )); then
            connector="│"  # last work-lab, devcontainer follows
          fi
          printf "  %s   └─ ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "$connector" "${wl_id:0:12}" "${container_name[$wl_id]}"
        done
      fi
      printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "${dc_id:0:12}" "${container_name[$dc_id]}"
    elif (( wl_count > 0 )); then
      # Only work-lab(s), no devcontainer
      if (( wl_count == 1 )); then
        local wl_id="${wl_array[0]}"
        printf "  └─ ${C_COMMAND}work-lab${C_RESET}      ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s (standalone)${C_RESET}\n" "${wl_id:0:12}" "${container_name[$wl_id]}"
      else
        # Multiple standalone work-labs
        local session_annotation
        session_annotation=$(printf "${C_ACCENT}(%d sessions)${C_RESET}" "$wl_count")
        printf "  └─ ${C_COMMAND}work-lab${C_RESET}      %b ${C_DIM}(standalone)${C_RESET}\n" "$session_annotation"
        local i=0
        for wl_id in "${wl_array[@]}"; do
          ((i++))
          local connector=" "
          printf "  %s   └─ ${C_DIM}%s${C_RESET}  ${C_PASS}●${C_RESET}  ${C_DIM}%s${C_RESET}\n" "$connector" "${wl_id:0:12}" "${container_name[$wl_id]}"
        done
      fi
    elif [[ -n "$dc_id" ]]; then
      # Only devcontainer (no work-lab) - show warning indicator
      printf "  └─ ${C_DIM}devcontainer${C_RESET}  ${C_DIM}%s${C_RESET}  ${C_WARN}○${C_RESET}  ${C_DIM}%s${C_RESET}  ${C_WARN}no work-lab${C_RESET}\n" "${dc_id:0:12}" "${container_name[$dc_id]}"
    fi
  done

  echo ""
  print_dim "$project_count project(s)"
}

cmd_up() {
  require_host

  # Ensure config directory exists (required for devcontainer mount)
  mkdir -p "$HOME/.config/work-lab"

  if ! command -v devcontainer &> /dev/null; then
    status_fail "devcontainer CLI not found"
    hint "npm install -g @devcontainers/cli"
    fail_exit
  fi

  # Detect project from current directory
  local project_root project_name
  project_root=$(find_git_root)
  if [[ -z "$project_root" ]]; then
    status_fail "Not in a git repository"
    hint "run 'work-lab up' from the root of a git project"
    fail_exit
  fi
  project_name=$(get_project_name "$project_root")

  banner "work-lab up"
  printf "  ${C_LABEL}project${C_RESET}  ${C_COMMAND}%s${C_RESET}\n" "$project_name"
  printf "  ${C_LABEL}path${C_RESET}     %s\n" "$project_root"

  # Build mount flags
  local mount_flags=()

  # Add project mount (the current git repo)
  mount_flags+=("--mount=type=bind,source=$project_root,target=/workspaces/project")
  printf "  ${C_LABEL}mount${C_RESET}    %s -> /workspaces/project\n" "$project_root"

  # Add additional mounts from config
  if (( ${#WORK_LAB_MOUNTS_RO[@]} > 0 )) || (( ${#WORK_LAB_MOUNTS_RW[@]} > 0 )); then
    echo ""
    subheader "Additional mounts:"
    readarray -t -O "${#mount_flags[@]}" mount_flags < <(build_mount_flags)
  fi

  echo ""
  activity "Starting devcontainer..."

  # Run devcontainer up
  devcontainer up --workspace-folder "$REPO_DIR" "${mount_flags[@]}"

  echo ""
  separator
  print_pass "Ready!"
  hint "work-lab mux   ${C_DIM}(recommended - persistent tmux session)${C_RESET}"
  hint "work-lab shell ${C_DIM}(one-off commands)${C_RESET}"
  printf "  ${C_LABEL}project at${C_RESET} ${C_COMMAND}/workspaces/project${C_RESET}\n"

  # Show sidecar mode tips
  if [[ -d "$project_root/.devcontainer" ]] || [[ -f "$project_root/.devcontainer.json" ]]; then
    echo ""
    subheader "Sidecar mode detected"
    detail "Project has its own devcontainer for building/testing"
    tip "Use 'work-lab dc <cmd>' to run commands in project devcontainer"
  fi
}

cmd_shell() {
  require_host

  local container_id
  container_id=$(find_container)
  if [[ -z "$container_id" ]]; then
    status_fail "Container not running"
    hint "work-lab up"
    fail_exit
  fi
  docker exec -it -u worklab -w /workspaces/project "$container_id" bash
}

cmd_mux() {
  require_host

  local container_id
  container_id=$(find_container)
  if [[ -z "$container_id" ]]; then
    status_fail "Container not running"
    hint "work-lab up"
    fail_exit
  fi

  # Check if configured mux is available in container
  if ! docker exec "$container_id" command -v "$WORK_LAB_MUX" &>/dev/null; then
    status_fail "$WORK_LAB_MUX not found in container"
    if [[ "$WORK_LAB_MUX" == "zellij" ]]; then
      hint "install zellij via ~/.config/work-lab/post-create.sh"
    fi
    fail_exit
  fi

  # Get project name for window naming
  local project_name
  project_name=$(docker exec "$container_id" bash -c 'basename /workspaces/project 2>/dev/null' || echo "project")

  # Attach to existing session or create a new one named 'lab'
  case "$WORK_LAB_MUX" in
    tmux)
      # Create or attach, then rename first window to project name
      docker exec -it -u worklab -w /workspaces/project "$container_id" \
        bash -c "tmux attach -t lab 2>/dev/null || (tmux new -s lab -n '$project_name')"
      ;;
    zellij)
      docker exec -it -u worklab -w /workspaces/project "$container_id" \
        zellij attach --create lab
      ;;
    *)
      status_fail "Unknown multiplexer: $WORK_LAB_MUX"
      hint "set WORK_LAB_MUX to 'tmux' or 'zellij'"
      fail_exit
      ;;
  esac
}

cmd_stop() {
  require_host

  local container_id
  container_id=$(find_container)
  if [[ -z "$container_id" ]]; then
    status_info "Container not running"
    exit 0
  fi
  activity "Stopping container..."
  docker stop "$container_id" > /dev/null
  status_ok "Stopped"
}

# Run command in associated project devcontainer (from inside work-lab or host)
cmd_dc() {
  local cmd="${1:-}"
  shift 2>/dev/null || true

  if [[ -z "$cmd" ]]; then
    echo "Usage: work-lab dc <command> [args...]"
    echo ""
    echo "Run a command in the project's devcontainer."
    echo ""
    echo "Examples:"
    printf "  ${C_COMMAND}work-lab dc npm test${C_RESET}        Run tests in devcontainer\n"
    printf "  ${C_COMMAND}work-lab dc make build${C_RESET}      Build project in devcontainer\n"
    printf "  ${C_COMMAND}work-lab dc bash${C_RESET}            Interactive shell in devcontainer\n"
    return 0
  fi

  # Find project path and name
  local project_path project_name
  if is_inside_container; then
    project_path="/workspaces/project"
    if [[ ! -d "$project_path" ]]; then
      status_fail "Project not mounted at /workspaces/project"
      fail_exit
    fi
    project_name=$(basename "$project_path")
  else
    project_path=$(find_git_root)
    if [[ -z "$project_path" ]]; then
      status_fail "Not in a git repository"
      fail_exit
    fi
    project_name=$(basename "$project_path")
  fi

  # Find the project's devcontainer using path-matching
  local dc_id exact_match="" fallback_match=""

  # Try exact path match first, then project name match
  while IFS= read -r cid; do
    [[ -z "$cid" ]] && continue

    # Get container info
    local cname local_folder
    cname=$(docker inspect --format '{{.Name}}' "$cid" 2>/dev/null | tr -d '/')
    local_folder=$(docker inspect --format '{{index .Config.Labels "devcontainer.local_folder"}}' "$cid" 2>/dev/null)

    # Skip work-lab containers
    if [[ "$cname" == *"work-lab"* ]]; then
      continue
    fi

    # Check for exact path match
    if [[ "$local_folder" == "$project_path" ]]; then
      exact_match="$cid"
      break
    fi

    # Check for project name match
    if [[ -n "$local_folder" ]]; then
      local folder_name
      folder_name=$(basename "$local_folder")
      if [[ "$folder_name" == "$project_name" ]]; then
        exact_match="$cid"
        break
      fi
    fi

    # Store first non-work-lab container as fallback
    if [[ -z "$fallback_match" ]]; then
      fallback_match="$cid"
    fi
  done < <(docker ps --filter "label=devcontainer.local_folder" --format '{{.ID}}' 2>/dev/null)

  # Use exact match if found, otherwise fallback
  if [[ -n "$exact_match" ]]; then
    dc_id="$exact_match"
  elif [[ -n "$fallback_match" ]]; then
    dc_id="$fallback_match"
    status_warn "No exact devcontainer match, using first available"
  fi

  if [[ -z "$dc_id" ]]; then
    status_fail "Project devcontainer not running"
    hint "start the project's devcontainer first"
    if is_inside_container; then
      tip "Run 'devcontainer up' from host in project directory"
    fi
    fail_exit
  fi

  # Run the command
  if [[ "$cmd" == "bash" ]] || [[ "$cmd" == "sh" ]] || [[ "$cmd" == "zsh" ]]; then
    docker exec -it "$dc_id" "$cmd" "$@"
  else
    docker exec "$dc_id" "$cmd" "$@"
  fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Update checking
# ─────────────────────────────────────────────────────────────────────────────
UPDATE_CHECK_CACHE_DIR="$HOME/.cache/work-lab"
UPDATE_CHECK_CACHE_FILE="$UPDATE_CHECK_CACHE_DIR/update-check"
UPDATE_CHECK_CACHE_TTL=$((24 * 60 * 60))  # 24 hours in seconds

# Compare two semantic versions: returns 0 if v1 < v2, 1 otherwise
# Strips leading 'v' from both versions
_version_lt() {
  local v1="${1#v}" v2="${2#v}"
  local IFS='.'
  # shellcheck disable=SC2206
  local i v1_parts=($v1) v2_parts=($v2)
  for ((i = 0; i < 3; i++)); do
    local p1="${v1_parts[i]:-0}" p2="${v2_parts[i]:-0}"
    if (( p1 < p2 )); then
      return 0
    elif (( p1 > p2 )); then
      return 1
    fi
  done
  return 1  # equal, not less than
}

# Fetch latest version from GitHub (returns version string without 'v' prefix)
_fetch_latest_version() {
  local url="https://api.github.com/repos/modern-tooling/work-lab/releases/latest"
  local response tag_name

  if ! command -v curl &>/dev/null; then
    return 1
  fi

  response=$(curl -sL --max-time 5 "$url" 2>/dev/null) || return 1

  if ! command -v jq &>/dev/null; then
    # fallback: parse with grep/sed
    tag_name=$(echo "$response" | grep -o '"tag_name"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"v\?\([^"]*\)".*/\1/')
  else
    tag_name=$(echo "$response" | jq -r '.tag_name // empty' 2>/dev/null)
  fi

  if [[ -z "$tag_name" ]]; then
    return 1
  fi

  # strip leading 'v' if present
  echo "${tag_name#v}"
}

# Get cached latest version (returns empty if cache expired or missing)
_get_cached_version() {
  if [[ ! -f "$UPDATE_CHECK_CACHE_FILE" ]]; then
    return 1
  fi

  local cache_time cached_version now
  cache_time=$(head -1 "$UPDATE_CHECK_CACHE_FILE" 2>/dev/null) || return 1
  cached_version=$(tail -1 "$UPDATE_CHECK_CACHE_FILE" 2>/dev/null) || return 1
  now=$(date +%s)

  if (( now - cache_time > UPDATE_CHECK_CACHE_TTL )); then
    return 1  # cache expired
  fi

  echo "$cached_version"
}

# Save version to cache
_save_cached_version() {
  local version="$1"
  mkdir -p "$UPDATE_CHECK_CACHE_DIR"
  printf '%s\n%s\n' "$(date +%s)" "$version" > "$UPDATE_CHECK_CACHE_FILE"
}

# Check for updates (uses cache, returns 0 if update available)
# Sets UPDATE_LATEST_VERSION variable
check_for_update() {
  local latest

  # try cache first
  latest=$(_get_cached_version)
  if [[ -z "$latest" ]]; then
    # cache miss or expired, fetch from GitHub
    latest=$(_fetch_latest_version) || return 1
    _save_cached_version "$latest"
  fi

  UPDATE_LATEST_VERSION="$latest"

  # compare versions
  if _version_lt "$VERSION" "$latest"; then
    return 0  # update available
  fi
  return 1  # up to date
}

cmd_upgrade() {
  local latest installed_via_homebrew=false

  header "Checking for updates..."

  # force fresh fetch (bypass cache)
  latest=$(_fetch_latest_version) || latest=""
  if [[ -z "$latest" ]]; then
    status_fail "Could not fetch latest version"
    hint "check your internet connection"
    hint "https://github.com/modern-tooling/work-lab/releases"
    fail_exit
  fi

  # update cache
  _save_cached_version "$latest"

  printf "  ${C_LABEL}current${C_RESET}   ${C_COMMAND}v%s${C_RESET}\n" "$VERSION"
  printf "  ${C_LABEL}latest${C_RESET}    ${C_COMMAND}v%s${C_RESET}\n" "$latest"
  echo ""

  if ! _version_lt "$VERSION" "$latest"; then
    status_ok "Already up to date"
    return 0
  fi

  # check installation method
  if command -v brew &>/dev/null && brew list work-lab &>/dev/null 2>&1; then
    installed_via_homebrew=true
  fi

  if [[ "$installed_via_homebrew" == "true" ]]; then
    status_info "Installed via Homebrew"
    activity "Running brew upgrade work-lab..."
    echo ""
    if brew upgrade work-lab; then
      echo ""
      status_ok "Upgraded to v$latest"
    else
      echo ""
      status_fail "Upgrade failed"
      hint "try running 'brew upgrade work-lab' manually"
      fail_exit
    fi
  else
    status_info "Not installed via Homebrew"
    echo ""
    print_accent "To upgrade, re-run the installer:"
    echo ""
    printf "  ${C_COMMAND}curl -fsSL https://raw.githubusercontent.com/modern-tooling/work-lab/main/install.sh | bash${C_RESET}\n"
    echo ""
    hint "https://github.com/modern-tooling/work-lab#installation"
  fi
}

cmd_doctor() {
  local container_id config_dir errors=0
  local mount_spec src_path tgt_path

  banner "work-lab doctor"

  # check work-lab repo
  header "Repository"
  if [[ -d "$REPO_DIR/.devcontainer" ]]; then
    status_ok "$REPO_DIR"
  else
    status_fail "not found at $REPO_DIR"
    ((errors++))
  fi

  # check dependencies
  header "Dependencies"
  if command -v docker &>/dev/null; then
    status_ok "docker: $(docker --version 2>/dev/null | head -n 1 || echo 'installed')"
    # Check if docker daemon is running
    if docker info &>/dev/null; then
      status_ok "docker daemon: running"
    else
      status_fail "docker daemon: not running"
      hint "start Docker Desktop or dockerd"
      ((errors++))
    fi
  else
    status_fail "docker: not found"
    hint "install from https://docs.docker.com/get-docker/"
    ((errors++))
  fi
  if command -v devcontainer &>/dev/null; then
    status_ok "devcontainer CLI: $(devcontainer --version 2>/dev/null || echo 'installed')"
  else
    status_fail "devcontainer CLI: not found"
    hint "npm install -g @devcontainers/cli"
    ((errors++))
  fi

  # check container status
  header "Container"
  if command -v docker &>/dev/null && docker info &>/dev/null; then
    container_id=$(find_container)
    if [[ -n "$container_id" ]]; then
      status_ok "running (id: ${container_id:0:12})"
    else
      status_info "not running"
      hint "work-lab up"
    fi
  else
    status_skip "cannot check (docker not available)"
  fi

  # show and validate configuration
  header "Configuration"
  config_dir="$HOME/.config/work-lab"
  if [[ -f "$config_dir/config" ]]; then
    status_ok "config file: $config_dir/config"
  else
    status_info "config file: not found (using defaults)"
  fi
  kv "WORK_LAB_IMAGE=" "$WORK_LAB_IMAGE"

  # check current project (git repo)
  header "Current project"
  local git_root
  git_root=$(find_git_root)
  if [[ -n "$git_root" ]]; then
    status_ok "$(get_project_name "$git_root")"
    detail "$git_root"
  else
    status_warn "not in a git repository"
    hint "run 'work-lab up' from within a git project"
  fi

  # validate configured mounts
  header "Configured mounts"
  if (( ${#WORK_LAB_MOUNTS_RO[@]} == 0 && ${#WORK_LAB_MOUNTS_RW[@]} == 0 )); then
    status_info "none configured (optional)"
  else
    # Check read-only mounts
    if (( ${#WORK_LAB_MOUNTS_RO[@]} > 0 )); then
      for mount_spec in "${WORK_LAB_MOUNTS_RO[@]}"; do
        if [[ "$mount_spec" != *:* ]]; then
          status_fail "invalid format (missing colon): $mount_spec"
          ((errors++))
          continue
        fi
        src_path="${mount_spec%%:*}"
        tgt_path="${mount_spec#*:}"
        # Expand ~ and $HOME
        src_path="${src_path/#\~/$HOME}"
        src_path="${src_path//\$HOME/$HOME}"
        if [[ -e "$src_path" ]]; then
          if [[ -r "$src_path" ]]; then
            status_ok "$src_path ${ICON_ARROW} $tgt_path (ro)"
          else
            status_fail "$src_path ${ICON_ARROW} $tgt_path (ro) - not readable"
            ((errors++))
          fi
        else
          status_warn "$src_path ${ICON_ARROW} $tgt_path (ro) - source not found"
        fi
      done
    fi
    # Check read-write mounts
    if (( ${#WORK_LAB_MOUNTS_RW[@]} > 0 )); then
      for mount_spec in "${WORK_LAB_MOUNTS_RW[@]}"; do
        if [[ "$mount_spec" != *:* ]]; then
          status_fail "invalid format (missing colon): $mount_spec"
          ((errors++))
          continue
        fi
        src_path="${mount_spec%%:*}"
        tgt_path="${mount_spec#*:}"
        # Expand ~ and $HOME
        src_path="${src_path/#\~/$HOME}"
        src_path="${src_path//\$HOME/$HOME}"
        if [[ -e "$src_path" ]]; then
          if [[ -r "$src_path" && -w "$src_path" ]]; then
            status_ok "$src_path ${ICON_ARROW} $tgt_path (rw)"
          else
            status_fail "$src_path ${ICON_ARROW} $tgt_path (rw) - not readable/writable"
            ((errors++))
          fi
        else
          status_warn "$src_path ${ICON_ARROW} $tgt_path (rw) - source not found"
        fi
      done
    fi
  fi

  # check user hooks
  header "Lifecycle hooks"
  if [[ -d "$config_dir" ]]; then
    if [[ -f "$config_dir/post-create.sh" ]]; then
      if [[ -x "$config_dir/post-create.sh" ]] || head -1 "$config_dir/post-create.sh" | grep -q '^#!'; then
        status_ok "post-create.sh"
      else
        status_warn "post-create.sh (missing shebang or not executable)"
      fi
    else
      status_info "post-create.sh (not found)"
    fi
    if [[ -f "$config_dir/post-start.sh" ]]; then
      if [[ -x "$config_dir/post-start.sh" ]] || head -1 "$config_dir/post-start.sh" | grep -q '^#!'; then
        status_ok "post-start.sh"
      else
        status_warn "post-start.sh (missing shebang or not executable)"
      fi
    else
      status_info "post-start.sh (not found)"
    fi
  else
    status_info "~/.config/work-lab/ not found (optional)"
  fi

  # mode detection and sidecar status
  header "Mode"
  if [[ -n "$git_root" ]]; then
    if [[ -d "$git_root/.devcontainer" ]] || [[ -f "$git_root/.devcontainer.json" ]]; then
      status_info "Sidecar mode"
      detail "Project has devcontainer - work-lab runs alongside it"

      # Check if project devcontainer is running
      if command -v docker &>/dev/null && docker info &>/dev/null; then
        local dc_id
        dc_id=$(docker ps --filter "label=devcontainer.local_folder=$git_root" \
          --format "{{.ID}}" 2>/dev/null | head -n 1)

        if [[ -n "$dc_id" ]]; then
          status_ok "project devcontainer: running (${dc_id:0:12})"
          tip "Use 'work-lab dc <cmd>' to run commands in project devcontainer"
        else
          status_warn "project devcontainer: not running"
          hint "devcontainer up --workspace-folder $git_root"
        fi
      fi
    else
      status_info "Standalone mode"
      detail "work-lab provides the development environment"
    fi
  else
    status_skip "cannot determine (not in a git repo)"
  fi

  # check for updates (uses 24-hour cache)
  header "Updates"
  if check_for_update; then
    status_info "v$UPDATE_LATEST_VERSION available (current: v$VERSION)"
    hint "work-lab upgrade"
  else
    status_ok "up to date (v$VERSION)"
  fi

  # summary
  echo ""
  separator
  if (( errors > 0 )); then
    print_fail "Found $errors error(s). Fix them before running 'work-lab up'."
    INTENTIONAL_EXIT=1
    return 1
  else
    print_pass "All checks passed. Ready to run 'work-lab up'."
    return 0
  fi
}

# Main
case "${1:-}" in
  up)
    cmd_up
    ;;
  shell)
    cmd_shell
    ;;
  mux|tmux)
    cmd_mux
    ;;
  stop)
    cmd_stop
    ;;
  ps)
    cmd_ps
    ;;
  dc)
    shift
    cmd_dc "$@"
    ;;
  doctor)
    cmd_doctor
    ;;
  upgrade)
    cmd_upgrade
    ;;
  version|--version|-v)
    cmd_version
    ;;
  release-notes)
    cmd_release_notes
    ;;
  help|--help|-h)
    usage
    ;;
  "")
    usage
    fail_exit
    ;;
  *)
    echo "Unknown command: $1"
    usage
    fail_exit
    ;;
esac
