#!/usr/bin/env bash
# dc-attach
# Copyright (c) 2026 Ryan Snodgrass. MIT License.
# Attach to a project's devcontainer from within work-lab.
#
# Usage: dc-attach [--help]
#
# Detects the running devcontainer for the mounted project at /workspaces/project
# and opens an interactive shell inside it. Uses path-matching to ensure we
# connect to the correct devcontainer when multiple are running.

set -Eeuo pipefail
trap 'printf "Error at line %d: exit %d\n" "$LINENO" "$?" >&2' ERR

readonly SCRIPT_NAME="${0##*/}"
readonly PROJECT_PATH="/workspaces/project"

# colors for output
readonly CYAN='\033[38;2;80;200;220m'
readonly GRAY='\033[38;2;140;150;160m'
readonly YELLOW='\033[38;2;230;170;100m'
readonly RED='\033[38;2;220;80;80m'
readonly RESET='\033[0m'

usage() {
  cat <<EOF
Usage: $SCRIPT_NAME [--help]

Attach to a project's devcontainer from within work-lab.

Options:
  --help    Show this help message

The script detects a running devcontainer for the project mounted at
$PROJECT_PATH and opens an interactive shell inside it.

Detection method:
  1. Find all running devcontainers (by label)
  2. Match against the project's source path on the host
  3. Fall back to first non-work-lab devcontainer if no exact match

EOF
}

log_info() {
  printf "${CYAN}[dc-attach]${RESET} %s\n" "$1"
}

log_warn() {
  printf "${YELLOW}[dc-attach]${RESET} %s\n" "$1"
}

log_error() {
  printf "${RED}[dc-attach]${RESET} %s\n" "$1" >&2
}

log_hint() {
  printf "${GRAY}%s${RESET}\n" "$1"
}

# Get the host path for the mounted project
# This reads from Docker's mount info to find the source path
get_project_host_path() {
  # The project is mounted at /workspaces/project
  # We need to find where it came from on the host
  # Check mount info or use a marker file if available

  # Method 1: Check if there's a .git directory and get the remote origin
  if [[ -d "$PROJECT_PATH/.git" ]]; then
    # Get the project name from git
    local project_name
    project_name=$(basename "$PROJECT_PATH")
    printf '%s' "$project_name"
    return 0
  fi

  # Method 2: Just use the directory name
  basename "$PROJECT_PATH"
}

# Find devcontainer matching the project path
# Returns container ID if found, empty string otherwise
find_devcontainer_for_project() {
  local project_name
  project_name=$(get_project_host_path)

  local exact_match=""
  local fallback_match=""

  # Get all devcontainers with local_folder label
  while IFS= read -r container_id; do
    [[ -z "$container_id" ]] && continue

    # Get container name and local_folder label
    local container_name local_folder
    container_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | tr -d '/')
    local_folder=$(docker inspect --format '{{index .Config.Labels "devcontainer.local_folder"}}' "$container_id" 2>/dev/null)

    # Skip work-lab containers
    if [[ "$container_name" == *"work-lab"* ]]; then
      continue
    fi

    # Check for exact path match (project name in local_folder path)
    if [[ -n "$local_folder" ]]; then
      local folder_name
      folder_name=$(basename "$local_folder")

      if [[ "$folder_name" == "$project_name" ]]; then
        # Exact match found
        exact_match="$container_id"
        break
      fi
    fi

    # Store first non-work-lab container as fallback
    if [[ -z "$fallback_match" ]]; then
      fallback_match="$container_id"
    fi

  done < <(docker ps --filter "label=devcontainer.local_folder" --format '{{.ID}}' 2>/dev/null)

  # Return exact match if found, otherwise fallback
  if [[ -n "$exact_match" ]]; then
    printf '%s' "$exact_match"
    return 0
  elif [[ -n "$fallback_match" ]]; then
    printf '%s' "$fallback_match"
    return 0
  fi

  return 1
}

# Get the default shell inside a container
get_container_shell() {
  local container_id="$1"

  # Try common shells in order of preference
  for shell in /bin/zsh /bin/bash /bin/sh; do
    if docker exec "$container_id" test -x "$shell" 2>/dev/null; then
      printf '%s' "$shell"
      return 0
    fi
  done

  printf '/bin/sh'
}

main() {
  # handle --help
  if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    usage
    exit 0
  fi

  # Check if docker is available
  if ! command -v docker &>/dev/null; then
    log_error "docker command not found"
    log_hint "  Docker must be available to attach to devcontainers"
    exit 1
  fi

  # Check if project is mounted
  if [[ ! -d "$PROJECT_PATH" ]]; then
    log_error "No project mounted at $PROJECT_PATH"
    log_hint "  Run 'work-lab up' from your project directory first"
    exit 1
  fi

  local project_name
  project_name=$(get_project_host_path)
  log_info "Looking for devcontainer for: $project_name"

  # Try to find the devcontainer
  local container_id
  if ! container_id=$(find_devcontainer_for_project); then
    log_error "No running devcontainer found for project"
    log_hint ""
    log_hint "  To start a devcontainer for your project:"
    log_hint "    1. Ensure your project has a .devcontainer/devcontainer.json"
    log_hint "    2. Run: devcontainer up --workspace-folder /workspaces/project"
    log_hint ""
    log_hint "  Or start it from your host machine using VS Code or the devcontainer CLI"
    exit 1
  fi

  # Get container info for display
  local container_name local_folder
  container_name=$(docker inspect --format '{{.Name}}' "$container_id" 2>/dev/null | tr -d '/')
  local_folder=$(docker inspect --format '{{index .Config.Labels "devcontainer.local_folder"}}' "$container_id" 2>/dev/null)

  # Check if this is an exact match or fallback
  local folder_basename
  folder_basename=$(basename "$local_folder" 2>/dev/null || echo "")
  if [[ "$folder_basename" != "$project_name" ]] && [[ -n "$folder_basename" ]]; then
    log_warn "No exact match found, using: $folder_basename"
  fi

  # Determine shell to use
  local shell_path
  shell_path=$(get_container_shell "$container_id")

  log_info "Attaching to: $container_name"
  log_info "Shell: $shell_path"
  printf '\n'

  # Exec into the container interactively
  exec docker exec -it "$container_id" "$shell_path" -l
}

main "$@"
